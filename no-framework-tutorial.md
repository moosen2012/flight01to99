# Create a PHP application without a Framework

创建没有框架的PHP应用程序

https://git.php.fail/lubiana/no-framework-tutorial

 [01-front-controller.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/01-front-controller.md "01-front-controller.md")[Changing port to 1235 to not clash with smtp default port](https://git.php.fail/lubiana/no-framework-tutorial/commit/d81535c3c0e6cc70459abc776955b59994cb9e6d)

[02-composer.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/02-composer.md "02-composer.md")[Update author name in composer chapter](https://git.php.fail/lubiana/no-framework-tutorial/commit/99a31e45d0000e8f3f4d20d2945e2fa1251e1fc6)

[03-error-handler.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/03-error-handler.md "03-error-handler.md")[fix some typos](https://git.php.fail/lubiana/no-framework-tutorial/commit/62cff766db5797fcc70515bd47d827392681994b)

[04-development-helpers.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/04-development-helpers.md "04-development-helpers.md")[fix some typos](https://git.php.fail/lubiana/no-framework-tutorial/commit/62cff766db5797fcc70515bd47d827392681994b)

 [05-http.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/05-http.md "05-http.md")[fix some typos](https://git.php.fail/lubiana/no-framework-tutorial/commit/62cff766db5797fcc70515bd47d827392681994b)

 [06-router.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/06-router.md "06-router.md")[fix some typos](https://git.php.fail/lubiana/no-framework-tutorial/commit/62cff766db5797fcc70515bd47d827392681994b)

 [07-dispatching-to-a-class.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/07-dispatching-to-a-class.md "07-dispatching-to-a-class.md")[fix some typos](https://git.php.fail/lubiana/no-framework-tutorial/commit/62cff766db5797fcc70515bd47d827392681994b)

 [08-inversion-of-control.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/08-inversion-of-control.md "08-inversion-of-control.md")[fix some typos](https://git.php.fail/lubiana/no-framework-tutorial/commit/62cff766db5797fcc70515bd47d827392681994b)

 [09-dependency-injector.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/09-dependency-injector.md "09-dependency-injector.md")[add small typo and wording improvements to chapters 9 and 10, update name of time service](https://git.php.fail/lubiana/no-framework-tutorial/commit/d880aeb9a65be20de02ea40ac9446e2aca3fbb3a)

[10-invoker.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/10-invoker.md "10-invoker.md")[add small typo and wording improvements to chapters 9 and 10, update name of time service](https://git.php.fail/lubiana/no-framework-tutorial/commit/d880aeb9a65be20de02ea40ac9446e2aca3fbb3a)

 [11-templating.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/11-templating.md "11-templating.md")[update chapter 11](https://git.php.fail/lubiana/no-framework-tutorial/commit/9b14e32639be24f5577288a6db962f32518b0252)

[12-configuration.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/12-configuration.md "12-configuration.md")[simplify chapter 12](https://git.php.fail/lubiana/no-framework-tutorial/commit/f857fa475239729cb9068ba745a82cd955c34917)

[13-refactoring.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/13-refactoring.md "13-refactoring.md")[add chapter about data repositories, and start work on perfomance chapter](https://git.php.fail/lubiana/no-framework-tutorial/commit/9a1f78947b8b6b8e42f22b5881e19f66a24d7c16)

 [14-middleware.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/14-middleware.md "14-middleware.md")[fix some typos and link to a blogpost about middleware pattern](https://git.php.fail/lubiana/no-framework-tutorial/commit/68d4abab8fda2a7ffb1dce37ecbb06a51232a8b2)

 [15-adding-content.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/15-adding-content.md "15-adding-content.md")[fix typos in chapters 15 to 17](https://git.php.fail/lubiana/no-framework-tutorial/commit/f5c444d4c74d54def04e710db7e656eb6c98004e)

 [16-data-repository.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/16-data-repository.md "16-data-repository.md")[fix typos in chapters 15 to 17](https://git.php.fail/lubiana/no-framework-tutorial/commit/f5c444d4c74d54def04e710db7e656eb6c98004e)

 [17-performance.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/17-performance.md "17-performance.md")[fix typos in chapters 15 to 17](https://git.php.fail/lubiana/no-framework-tutorial/commit/f5c444d4c74d54def04e710db7e656eb6c98004e)

 [18-caching.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/18-caching.md "18-caching.md")[add perfomance chapters](https://git.php.fail/lubiana/no-framework-tutorial/commit/ececd7dcb5b37e7679831fa4b58dfd58cddf5acd)

 [LICENSE](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/LICENSE "LICENSE")[Create LICENSE](https://git.php.fail/lubiana/no-framework-tutorial/commit/c9df0411b489c968e893e58cb0adb04a63b94cdc)

 [README.md](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/README.md "README.md")[fix some typos and link to a blogpost about middleware pattern](https://git.php.fail/lubiana/no-framework-tutorial/commit/68d4abab8fda2a7ffb1dce37ecbb06a51232a8b2)

 [Vagrantfile](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/Vagrantfile "Vagrantfile")

 [enable intl extension](https://git.php.fail/lubiana/no-framework-tutorial/commit/997d160796d9a2123f01c43d9b5ca00b76bb614b)

Hello and welcome to this tutorial with helps you in understanding how to write complex apps without the help of a framework. This tutorial is not for people who have never written PHP before, you should at least have some experience with object oriented PHP and be able to look at the official PHP-Documentation to figure out what a function or class we are using does.  
您好，欢迎来到本教程，帮助您了解如何在没有框架的帮助下编写复杂的应用程序。本教程不适合以前从未编写过PHP的人，你至少应该有一些面向对象PHP的经验，并且能够查看官方的PHP文档来弄清楚我们正在使用的函数或类是什么。

I often hear people talking about frameworks as a solution to all the problems that you have in software development. But in my opinion its even worse to use a framework if you do not know what you are doing, because often are fighting more against the framework than actually solving the problem you should be working on. Even if you know what you are doing i think it is good to get to know how the frameworks you are using work under the hood and what challenges they actually solve for you.  
我经常听到人们谈论框架作为软件开发中所有问题的解决方案。但在我看来，如果你不知道自己在做什么，使用框架就更糟糕了，因为你经常与框架作斗争，而不是真正解决你应该解决的问题。即使你知道你在做什么，我认为了解你使用的框架是如何工作的，以及它们实际上为你解决了什么挑战是很好的。

## [](https://git.php.fail/lubiana/no-framework-tutorial#credit)Credit: 信贷：

This tutorial is based on the great [tutorial by Patrick Louys](https://github.com/PatrickLouys/no-framework-tutorial). My version is way more opiniated and uses some newer PHP features. But you should still check out his tutorial which is still very great and helped me personally a lot in taking the next step in my knowledge about PHP development. There is also an [amazing book](https://patricklouys.com/professional-php/) which expands on the topics covered in this tutorial.  
本教程基于帕特里克路易斯的伟大教程。我的版本更加固执己见，并使用了一些新的PHP功能。但你仍然应该看看他的教程，这仍然是非常伟大的，并帮助我个人在我的PHP开发知识的下一步很多。还有一本令人惊叹的书，它扩展了本教程中涵盖的主题。

## [](https://git.php.fail/lubiana/no-framework-tutorial#getting-started)Getting started. 开始吧。

As I am using a fairly new version of PHP in this tutorial I have added a Vagrantfile to this tutorial. If you do not have PHP8.1 installed on your computer you can use the following commands to try out all the examples:  
由于我在本教程中使用的是一个相当新的PHP版本，因此我在本教程中添加了一个Vagrantfile。如果您的计算机上没有安装PHP8.1，您可以使用以下命令来尝试所有示例：

```shell
vagrant up
vagrant ssh
cd app
```

I have exposed the port 1235 to be used in the VM, if you would like to use another one you are free to modify the Vagrantfile.  
我已经公开了在VM中使用的端口1235，如果你想使用另一个端口，你可以自由修改Vagrantfile。

### Front Controller 前端控制器

A [front controller](http://en.wikipedia.org/wiki/Front_Controller_pattern) is a single point of entry for your application.  
前端控制器是应用程序的单一入口点。

To start, create an empty directory for your project. You also need an entry point where all requests will go to. This means you will have to create an `index.php` file.  
首先，为项目创建一个空目录。您还需要一个入口点，所有请求都将转到该入口点。这意味着您必须创建一个 `index.php` 文件。

A common way to do this is to just put the `index.php` in the root folder of the projects. This is also how some frameworks do it. Let me explain why you should not do this.  
一种常见的方法是将 `index.php` 放在项目的根文件夹中。有些框架也是这样做的，让我解释一下为什么你不应该这样做。

The `index.php` is the starting point, so it has to be inside the web server directory. This means that the web server has access to all subdirectories. If you set things up properly, you can still prevent it from accessing your subfolders where your application files are.  
`index.php` 是起点，所以它必须在Web服务器目录中。这意味着Web服务器可以访问所有子目录。如果设置正确，仍然可以防止它访问应用程序文件所在的磁盘。

But sometimes things don't go according to plan. And if something goes wrong and your files are set up as above, your whole application source code could be exposed to visitors. I won't have to explain why this is not a good thing.  
但有时事情并不按计划进行。如果出现问题，并且您的文件设置如上所述，则整个应用程序源代码可能会暴露给访问者。我不需要解释为什么这不是一件好事。

So instead of doing that, create a folder in your project folder called `public`. This is a good time to create an `src` folder for your application, also in the project root folder.  
因此，不要这样做，而是在项目文件夹中创建一个名为 `public` 的文件夹。这是为您的应用程序创建 `src` 文件夹的好时机，也是在项目根文件夹中。

Inside the `public` folder you can now create your `index.php`. Remember that you don't want to expose anything here, so put just the following code in there:  
在 `public` 文件夹中，您现在可以创建您的 `index.php` 。请记住，您不想在这里暴露任何东西，因此只需将以下代码放在那里：

```php
<?php 
declare(strict_types=1); 

require __DIR__ . '/../src/Bootstrap.php';
```

`__DIR__` is a [magic constant](http://php.net/manual/en/language.constants.predefined.php) that contains the path of the directory. By using it, you can make sure that the `require` always uses the same relative path to the file it is used in. Otherwise, if you call the `index.php` from a different folder it will not find the file.  
`__DIR__` 是一个魔法常量，包含目录的路径。通过使用它，您可以确保 `require` 始终使用相同的文件相对路径。否则，如果您从不同的文件夹中调用 `index.php` ，它将无法找到该文件。

`declare(strict_types = 1);` sets the current file to [strict typing](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict). In this tutorial we are going to use this for all PHP files. This means that you can't just pass an integer as a parameter to a method that requires a string. If you don't use strict mode, it would be automatically casted to the required type. With strict mode, it will throw an Exception if it is the wrong type.  
`declare(strict_types = 1);` 将当前文件设置为严格类型。在本教程中，我们将对所有PHP文件使用此方法。这意味着你不能仅仅将一个整数作为参数传递给一个需要字符串的方法。如果不使用严格模式，它将自动转换为所需的类型。在严格模式下，如果类型错误，它将抛出一个Exception。

The `Bootstrap.php` will be the file that wires your application together. We will get to it shortly.  
`Bootstrap.php` 将是将您的应用程序连接在一起的文件。我们很快就会谈到它。

The rest of the public folder is reserved for your public asset files (like JavaScript files and stylesheets).  
公共文件夹的其余部分保留用于公共资产文件（如JavaScript文件和样式表）。

Now navigate inside your `src` folder and create a new `Bootstrap.php` file with the following content:  
现在在 `src` 文件夹中导航并创建一个新的 `Bootstrap.php` 文件，其中包含以下内容：

```php
<?php 
declare(strict_types=1);

echo 'Hello World!';
```

Now let's see if everything is set up correctly. Open up a console and navigate into your projects `public` folder. In there type `php -S 0.0.0.0:1235` and press enter. This will start the built-in webserver and you can access your page in a browser with `http://localhost:1235`. You should now see the 'hello world' message.  
现在让我们看看是否一切都设置正确。打开一个控制台并导航到您的项目 `public` 文件夹。在那里输入 `php -S 0.0.0.0:1235` 并按回车键。这将启动内置的Web服务器，您可以使用 `http://localhost:1235` 在浏览器中访问您的页面。你现在应该看到'hello world'消息。

If there is an error, go back and try to fix it. If you only see a blank page, check the console window where the server is running for errors.  
如果出现错误，请返回并尝试修复它。如果您只看到一个空白页，请检查服务器运行的控制台窗口是否有错误。

Now would be a good time to commit your progress. If you are not already using Git, set up a repository now. This is not a Git tutorial so I won't go over the details. But using version control should be a habit, even if it is just for a tutorial project like this.  
现在是你承诺进展的好时机。如果你还没有使用Git，现在就建立一个仓库。这不是一个Git教程，所以我不会去详细介绍。但是使用版本控制应该是一种习惯，即使只是像这样的教程项目。

Some editors and IDE's put their own files into your project folders. If that is the case, create a `.gitignore` file in your project root and exclude the files/directories. Below is an example for PHPStorm:  
有些编辑器和IDE会将它们自己的文件放到你的项目文件夹中。如果是这种情况，请在项目根目录中创建一个 `.gitignore` 文件，并排除文件/目录。下面是一个PHPStorm的例子：

```text
.idea/
```

### Composer 作曲家

[Composer](https://getcomposer.org/) is a dependency manager for PHP.  
Composer是PHP的依赖管理器。

Just because you are not using a framework does not mean you will have to reinvent the wheel every time you want to do something. With Composer, you can install third-party libraries for your application.  
仅仅因为你没有使用框架并不意味着你每次想做一些事情的时候都必须重新发明轮子。使用Composer，您可以为您的应用程序安装第三方库。

If you don't have Composer installed already, head over to the website and install it. You can find Composer packages for your project on [Packagist](https://packagist.org/).  
如果你还没有安装Composer，请到网站上安装它。你可以在Packagist上找到你项目的Composer软件包。

Create a new file in your project root folder called `composer.json`. This is the Composer configuration file that will be used to configure your project and its dependencies. It must be valid JSON or Composer will fail.  
在项目根文件夹中创建一个名为 `composer.json` 的新文件。这是Composer配置文件，将用于配置项目及其依赖项。它必须是有效的JSON，否则Composer将失败。

Add the following content to the file:  
将以下内容添加到文件中：

```json
{
  "name": "lubian/no-framework",
  "require": {
    "php": "^8.1"
  },
  "autoload": {
    "psr-4": {
      "Lubian\\NoFramework\\": "src/"
    }
  },
  "authors": [
    {
      "name": "example",
      "email": "test@example.com"
    }
  ]
}
```

In the autoload part you can see that I am using the `Lubian\NoFramework` namespace for the project. You can use whatever fits your project there, but from now on I will always use the `Lubian\NoFramework` namespace in my examples. Just replace it with your namespace in your own code.  
在autoload部分，你可以看到我正在为项目使用 `Lubian\NoFramework` 命名空间。你可以使用任何适合你的项目，但从现在开始，我将在我的示例中使用 `Lubian\NoFramework` 命名空间。只需在您自己的代码中将其替换为您的命名空间即可。

I have also defined, that all my code and classes in the 'Lubian\NoFramework' namespace lives under the './src' folder.  
我还定义了，我在'Lubian\NoFramework'命名空间中的所有代码和类都位于'./ src'文件夹。

As the Bootstrap.php file is placed in that directory we should add the namespace to the File as well. Here is my current Bootstrap.php as a reference:  
由于Bootstrap.php文件位于该目录中，因此我们也应该将名称空间添加到File中。以下是我目前的Bootstrap.php作为参考：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework;

echo 'Hello World!';
```

Open a new console window and navigate into your project root folder. There run `composer update`.  
打开一个新的控制台窗口并导航到项目根文件夹。运行 `composer update` 。

Composer creates a `composer.lock` file that locks in your dependencies and a vendor directory.  
Composer创建一个 `composer.lock` 文件，锁定您的依赖项和供应商目录。

Committing the `composer.lock` file into version control is generally good practice for projects. It allows continuation testing tools (such as [Travis CI](https://travis-ci.org/)) to run the tests against the exact same versions of libraries that you're developing against. It also allows all people who are working on the project to use the exact same version of libraries i.e. it eliminates a source of "works on my machine" problems.  
将 `composer.lock` 文件提交到版本控制中通常是项目的良好实践。它允许延续测试工具（如Travis CI）对您正在开发的库的完全相同的版本运行测试。它还允许所有从事项目的人使用完全相同版本的库，即消除了“在我的机器上工作”问题的来源。

That being said, [you don't want to put the actual source code of your dependencies in your git repository](https://getcomposer.org/doc/faqs/should-i-commit-the-dependencies-in-my-vendor-directory.md). So let's add a rule to our `.gitignore` file:  
也就是说，你不想把依赖项的实际源代码放在你的git仓库中。因此，让我们在 `.gitignore` 文件中添加一条规则：

```text
vendor/
```

Now you have successfully created an empty playground which you can use to set up your project.  
现在，您已经成功创建了一个空的操场，您可以使用它来设置您的项目。

### Error Handler 错误处理程序

An error handler allows you to customize what happens if your code results in an error.  
错误处理程序允许您自定义代码导致错误时发生的情况。

A nice error page with a lot of information for debugging goes a long way during development. So the first package for your application will take care of that.  
一个包含大量调试信息的漂亮的错误页面在开发过程中会有很大的帮助。因此，您的应用程序的第一个包将处理此问题。

I like [filp/whoops](https://github.com/filp/whoops), so I will show how you can install that package for your project. If you prefer another package, feel free to install that one. This is the beauty of programming without a framework, you have total control over your project.  
我喜欢filp/whoops，所以我将向你展示如何为你的项目安装这个包。如果您更喜欢其他软件包，请随意安装该软件包。这就是没有框架的编程之美，你可以完全控制你的项目。

An alternative package would be: [PHP-Error](https://github.com/JosephLenton/PHP-Error)  
另一个包是：PHP-Error

To install a new package, open up your `composer.json` and add the package to the require part. It should now look like this:  
要安装一个新的软件包，打开你的 `composer.json` 并将该软件包添加到require部分。它现在应该看起来像这样：

```php
"require": {
    "php": ">=8.1.0",
    "filp/whoops": "^2.14"
},
```

Now run `composer update` in your console, and it will be installed.  
现在在您的控制台中运行 `composer update` ，它将被安装。

Another way to install packages is to simply type "composer require filp/whoops" into your terminal at the project root, i that case composer automatically installs the package and updates your composer.json-file.  
安装软件包的另一种方法是在项目根目录下的终端中输入“composer require filp/whoops”，这样composer就会自动安装软件包并更新composer. json文件。

But you can't use it yet. PHP won't know where to find the files for the classes. For this you will need an autoloader, ideally a [PSR-4](http://www.php-fig.org/psr/psr-4/) autoloader. Composer already takes care of this for you, so you only have to add a `require __DIR__ . '/../vendor/autoload.php';` to your `Bootstrap.php`.  
但你还不能用。PHP不知道在哪里可以找到这些类的文件。为此，您需要一个自动装弹机，最好是PSR-4自动装弹机。Composer已经为您处理了这一点，因此您只需将 `require __DIR__ . '/../vendor/autoload.php';` 添加到 `Bootstrap.php` 。

**Important:** Never show any errors in your production environment. A stack trace or even just a simple error message can help someone to gain access to your system. Always show a user-friendly error page instead and send an email to yourself, write to a log or something similar. So only you can see the errors in the production environment.  
重要提示：永远不要在生产环境中显示任何错误。一个堆栈跟踪，甚至只是一个简单的错误消息，都可以帮助别人访问您的系统。总是显示一个用户友好的错误页面，而不是发送电子邮件给自己，写日志或类似的东西。因此，只有您可以看到生产环境中的错误。

For development that does not make sense though -- you want a nice error page. The solution is to have an environment switch in your code. We use the getenv() function here to check the environment and define the 'dev' env as standard in case no environment has been set.  
对于没有意义的开发，您需要一个漂亮的错误页面。解决方案是在代码中设置一个环境开关。我们在这里使用getenv（）函数来检查环境，并在没有设置环境的情况下将'dev' env定义为标准。

Then after the error handler registration, throw an `Exception` to test if everything is working correctly. Your `Bootstrap.php` should now look similar to this:  
然后在错误处理程序注册之后，抛出一个 `Exception` 来测试是否一切正常。你的 `Bootstrap.php` 现在应该看起来像这样：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework;

use Whoops\Handler\PrettyPageHandler;
use Whoops\Run;

require __DIR__ . '/../vendor/autoload.php';

$environment = getenv('ENVIRONMENT') ?: 'dev';

error_reporting(E_ALL);

$whoops = new Run;
if ($environment === 'dev') {
    $whoops->pushHandler(new PrettyPageHandler);
} else {
    $whoops->pushHandler(function (\Throwable $e) {
        error_log("Error: " . $e->getMessage(), $e->getCode());
        echo 'An Error happened';
    });
}
$whoops->register();

throw new \Exception("Ooooopsie");
```

You should now see a error page with the line highlighted where you throw the exception. If not, go back and debug until you get it working. Now would also be a good time for another commit.  
您现在应该看到一个错误页面，其中突出显示了抛出异常的那一行。如果没有，则返回并调试，直到它工作。现在也是另一次提交的好时机。

### Development Helpers 发展助手

I have added some more helpers to my composer.json that help me with development. As these are scripts and programms used only for development they should not be used in a production environment. Composer has a specific sections in its file called "dev-dependencies", everything that is required in this section does not get installed in production.  
我在composer.json中添加了更多的帮助器来帮助我进行开发。由于这些脚本和程序仅用于开发，因此不应在生产环境中使用。Composer在其文件中有一个特定的部分，称为"dev—dependencies"，这一部分所需的所有内容都不会在生产中安装。

Let's install our dev-helpers and i will explain them one by one: `composer require --dev phpstan/phpstan symfony/var-dumper slevomat/coding-standard symplify/easy-coding-standard rector/rector`  
让我们安装我们的dev—helpers，我将逐一解释它们： `composer require --dev phpstan/phpstan symfony/var-dumper slevomat/coding-standard symplify/easy-coding-standard rector/rector`

#### [](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/04-development-helpers.md#static-code-analysis-with-phpstan)Static Code Analysis with phpstan

使用phpstan进行静态代码分析

Phpstan is a great little tool, that tries to understand your code and checks if you are making any grave mistakes or create bad defined interfaces and structures. It also helps in finding logic-errors, dead code, access to array elements that are not (or not always) available, if-statements that always are true and a lot of other stuff.  
Phpstan是一个很棒的小工具，它试图理解你的代码，并检查你是否犯了任何严重的错误，或者创建了定义不好的接口和结构。它还有助于查找逻辑错误，死代码，访问不可用（或不总是）的数组元素，总是为真的if语句以及许多其他东西。

A very simple example would be a small functions that takes a DateTime-Object and prints it in a human-readable format.  
一个非常简单的例子是一个小函数，它接受一个DateTime—Object并以人类可读的格式打印它。

```php
/**
 * @param \DateTime $date
 * @return void
 */
function printDate($date) {
    $date->format('Y-m-d H:i:s');
}

printDate('now');
```

if we run phpstan with the command `./vendor/bin/phpstan analyse --level 9 ./src/`  
如果我们运行phpstan命令 `./vendor/bin/phpstan analyse --level 9 ./src/`

It firstly tells us that calling "format" on a DateTime-Object without outputting or returning the function result has no use, and secondly, that we are calling the function with a string instead of a datetime object.  
它首先告诉我们，在DateTime—Object上调用"format"而不输出或返回函数结果是没有用的，其次，我们用字符串而不是datetime对象调用函数。

```shell
1/1 [▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓] 100%

 ------ --------------------------------------------------------------------------------------------- 
Line   Bootstrap.php
 ------ --------------------------------------------------------------------------------------------- 
30     Call to method DateTime::format() on a separate line has no effect.                          
33     Parameter #1 $date of function Lubian\NoFramework\printDate expects DateTime, string given.
 ------ --------------------------------------------------------------------------------------------- 
```

The second error is something that "declare strict-types" already catches for us, but the first error is something that we usually would not discover easily without specially looking for this error-type.  
第二个错误是"declare strict—types"已经为我们捕获的，但是第一个错误是我们通常不容易发现的，除非专门寻找这个错误类型。

We can add a simple config file called `phpstan.neon` to our project so that we do not have to specify the error level and path everytime we want to check our code for errors:  
我们可以在项目中添加一个名为 `phpstan.neon` 的简单配置文件，这样我们就不必在每次检查代码错误时指定错误级别和路径：

```yaml
parameters:
    level: max
    paths:
        - src
```

now we can just call `./vendor/bin/phpstan analyze` and have the same setting for every developer working in our project  
现在我们可以调用 `./vendor/bin/phpstan analyze` ，并为在我们项目中工作的每个开发人员提供相同的设置

With this settings we have already a great setup to catch some errors before we execute the code, but it still allows us some silly things, therefore we want to add install some packages that enforce rules that are a little stricter.  
有了这个设置，我们已经有了一个很好的设置，可以在执行代码之前捕获一些错误，但它仍然允许我们做一些愚蠢的事情，因此我们想添加安装一些强制执行规则的软件包。

```shell
composer require --dev phpstan/extension-installer
composer require --dev phpstan/phpstan-strict-rules thecodingmachine/phpstan-strict-rules
```

During the first install you need to allow the extension installer to actually install the extension. The second command installs some more strict rules and activates them in phpstan.  
在第一次安装期间，您需要允许扩展安装程序实际安装扩展。第二个命令安装一些更严格的规则，并在phpstan中激活它们。

If we now rerun phpstan it already tells us about some errors we have made:  
如果我们现在重新开始，它已经告诉我们一些我们犯过的错误：

```text
 ------ ----------------------------------------------------------------------------------------------- 
Line   Bootstrap.php
 ------ ----------------------------------------------------------------------------------------------- 
10     Short ternary operator is not allowed. Use null coalesce operator if applicable or consider    
       using long ternary.                                                                            
25     Do not throw the \Exception base class. Instead, extend the \Exception base class. More info:  
       http://bit.ly/subtypeexception                                                                 
26     Unreachable statement - code above always terminates.
 ------ ----------------------------------------------------------------------------------------------- 
```

The last two Errors are caused by the Exception we have used to test the ErrorHandler in the last chapter if we remove that we should be able to fix that. The first error is something we could fix, but I don't want to focus on that specific problem right now. Phpstan gives us the option to ignore some errors and handle them later. If for example we are working on an old legacy codebase and wanted to add static analysis to it but can't because we would get 1 Million error messages everytime we use phpstan, we could add all those errors to a list and tell phpstan to only bother us about new errors we are adding to our code.  
最后两个错误是由我们在上一章中用来测试错误的异常引起的，如果我们删除它，我们应该能够修复它。第一个错误是我们可以修复的，但我现在不想专注于那个特定的问题。Phpstan允许我们忽略一些错误，并在以后处理它们。例如，如果我们正在处理一个旧的遗留代码库，并希望添加静态分析，但不能，因为我们每次使用phpstan都会收到100万条错误消息，我们可以将所有这些错误添加到一个列表中，并告诉phpstan只打扰我们添加到代码中的新错误。

In order to use that we have to add an empty file `phpstan-baseline.neon` to our project, include that in the `phpstan.neon` file and run phpstan with the `--generate-baseline` option:  
为了使用它，我们必须添加一个空文件 `phpstan-baseline.neon` 到我们的项目中，将其包含在 `phpstan.neon` 文件中，并使用 `--generate-baseline` 选项运行phpstan：

```yaml
includes:
    - phpstan-baseline.neon

parameters:
    level: max
    paths:
        - src
```

```shell
[vagrant@archlinux app]$ ./vendor/bin/phpstan analyze --generate-baseline
Note: Using configuration file /home/vagrant/app/phpstan.neon.
 1/1 [▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓] 100%



 [OK] Baseline generated with 1 error.                                                                                  
```

you can read more about the possible parameters and usage options in the [documentation](https://phpstan.org/user-guide/getting-started)  
您可以在文档中阅读有关可能的参数和使用选项的更多信息

#### [](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/04-development-helpers.md#easy-coding-standard)Easy-Coding-Standard 易编码标准

There are two great tools that help us with applying a consistent coding style to our project as well as check and automatically fix some other errors and oversights that we might not bother with when writing our code.  
有两个很好的工具可以帮助我们在项目中应用一致的编码风格，以及检查和自动修复一些我们在编写代码时可能不会遇到的其他错误和疏忽。

The first one is [PHP Coding Standards Fixer](https://cs.symfony.com/) which can automatically detect violations of a defined coding standard and fix them. The second tool is [PHP CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer) which basically does the same has in my experience some more Rules available that we can apply to our code.  
第一个是PHP Coding Standards Fixer，它可以自动检测违反定义的编码标准的行为并修复它们。第二个工具是PHP CodeSniffer，它基本上做同样的事情，根据我的经验，我们可以将更多的规则应用于我们的代码。

But we are going to use neither of those tools directly and instead choose the [Easy Coding Standard](https://github.com/symplify/easy-coding-standard) which allows us to combine rules from both mentioned tools, and also claims to run much faster. You could check out the documentation and decide on your own coding standard. Or use the one provided by me, which is base on PSR-12 but adds some highly opiniated options. First create a file 'ecs.php' and either add your own configuration or copy the prepared one:  
但是我们不会直接使用这两种工具，而是选择了Easy Coding Standard，它允许我们联合收割机从这两种工具中组合规则，并且声称运行速度更快。您可以查看文档并决定自己的编码标准。或者使用我提供的一个，它是基于PSR-12，但增加了一些非常自以为是的选项。首先创建一个文件'ecs.php'，然后添加您自己的配置或复制准备好的配置：

```php
<?php declare(strict_types=1);

use PhpCsFixer\Fixer\Import\OrderedImportsFixer;
use PhpCsFixer\Fixer\Operator\NewWithBracesFixer;
use PhpCsFixer\Fixer\PhpTag\BlankLineAfterOpeningTagFixer;
use SlevomatCodingStandard\Sniffs\Classes\ClassConstantVisibilitySniff;
use SlevomatCodingStandard\Sniffs\ControlStructures\NewWithoutParenthesesSniff;
use SlevomatCodingStandard\Sniffs\Namespaces\AlphabeticallySortedUsesSniff;
use SlevomatCodingStandard\Sniffs\Namespaces\DisallowGroupUseSniff;
use SlevomatCodingStandard\Sniffs\Namespaces\MultipleUsesPerLineSniff;
use SlevomatCodingStandard\Sniffs\Namespaces\NamespaceSpacingSniff;
use SlevomatCodingStandard\Sniffs\Namespaces\ReferenceUsedNamesOnlySniff;
use SlevomatCodingStandard\Sniffs\Namespaces\UseSpacingSniff;
use SlevomatCodingStandard\Sniffs\TypeHints\DeclareStrictTypesSniff;
use SlevomatCodingStandard\Sniffs\TypeHints\UnionTypeHintFormatSniff;
use Symplify\EasyCodingStandard\Config\ECSConfig;
use Symplify\EasyCodingStandard\ValueObject\Set\SetList;

return static function (ECSConfig $config): void {
    $config->parallel();
    $config->paths([__DIR__ . '/src', __DIR__ . '/ecs.php', __DIR__ . '/rector.php']);
    $config->skip([BlankLineAfterOpeningTagFixer::class, OrderedImportsFixer::class, NewWithBracesFixer::class]);

    $config->sets([
        SetList::PSR_12,
        SetList::STRICT,
        SetList::ARRAY,
        SetList::SPACES,
        SetList::DOCBLOCK,
        SetList::CLEAN_CODE,
        SetList::COMMON,
        SetList::COMMENTS,
        SetList::NAMESPACES,
        SetList::SYMPLIFY,
        SetList::CONTROL_STRUCTURES,
    ]);

    // force visibility declaration on class constants
    $config->ruleWithConfiguration(ClassConstantVisibilitySniff::class, [
        'fixable' => true,
    ]);

    // sort all use statements
    $config->rules([
        AlphabeticallySortedUsesSniff::class,
        DisallowGroupUseSniff::class,
        MultipleUsesPerLineSniff::class,
        NamespaceSpacingSniff::class,
    ]);

    // import all namespaces, and even php core functions and classes
    $config->ruleWithConfiguration(
        ReferenceUsedNamesOnlySniff::class,
        [
            'allowFallbackGlobalConstants' => false,
            'allowFallbackGlobalFunctions' => false,
            'allowFullyQualifiedGlobalClasses' => false,
            'allowFullyQualifiedGlobalConstants' => false,
            'allowFullyQualifiedGlobalFunctions' => false,
            'allowFullyQualifiedNameForCollidingClasses' => true,
            'allowFullyQualifiedNameForCollidingConstants' => true,
            'allowFullyQualifiedNameForCollidingFunctions' => true,
            'searchAnnotations' => true,
        ]
    );

    // define newlines between use statements
    $config->ruleWithConfiguration(UseSpacingSniff::class, [
        'linesCountBeforeFirstUse' => 1,
        'linesCountBetweenUseTypes' => 1,
        'linesCountAfterLastUse' => 1,
    ]);

    // strict types declaration should be on same line as opening tag
    $config->ruleWithConfiguration(DeclareStrictTypesSniff::class, [
        'declareOnFirstLine' => true,
        'spacesCountAroundEqualsSign' => 0,
    ]);

    // disallow ?Foo typehint in favor of Foo|null
    $config->ruleWithConfiguration(UnionTypeHintFormatSniff::class, [
        'withSpaces' => 'no',
        'shortNullable' => 'no',
        'nullPosition' => 'last',
    ]);

    // Remove useless parentheses in new statements
    $config->rule(NewWithoutParenthesesSniff::class);
};
```

You can now use `./vendor/bin/ecs` to list all violations of the defined standard and `./vendor/bin/ecs --fix` to automatically fix them.  
现在，您可以使用 `./vendor/bin/ecs` 列出所有违反定义标准的情况，使用 `./vendor/bin/ecs --fix` 自动修复这些情况。

#### [](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/04-development-helpers.md#rector)Rector 校长

The next tool helps us with automatic refactorings and upgrades to newer PHP versions.  
下一个工具帮助我们自动重构和升级到新的PHP版本。

Place a file called `rector.php` in your app directory and put in the following content:  
将一个名为 `rector.php` 的文件放在您的应用程序目录中，并放入以下内容：

```php
<?php

declare(strict_types=1);

use Rector\Config\RectorConfig;
use Rector\Set\ValueObject\LevelSetList;

return static function (RectorConfig $rectorConfig): void {
    $rectorConfig->paths([__DIR__ . '/src', __DIR__ . '/rector.php', __DIR__ . '/ecs.php']);

    $rectorConfig->importNames();

    $rectorConfig->sets([
        LevelSetList::UP_TO_PHP_81,
    ]);
};
```

This config fixes your code and replaces function call and constructs that are deprecated in modern php versions. This includes all fixes from PHP 5.2 up to PHP 8.1. You can take a look at all the rules [here](https://github.com/rectorphp/rector/blob/main/docs/rector_rules_overview.md#php52).  
这个配置修复了你的代码，并替换了在现代php版本中被弃用的函数调用和构造。这包括从PHP 5.2到PHP 8.1的所有修复。你可以看看这里的所有规则。

To run this tool simply type `./vendor/bin/rector process` in your console. This should not to much right now, but will be quite useful when php 8.2 or newer versions are released.  
要运行此工具，只需在控制台中键入 `./vendor/bin/rector process` 。现在这还不算什么，但当php 8.2或更新版本发布时会非常有用。

#### [](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/04-development-helpers.md#symfony-var-dumper)Symfony Var-Dumper

another great tool for some quick debugging without xdebug is the symfony var-dumper. This just gives us some small functions.  
另一个不使用xdebug的快速调试工具是symfony var-dumper。这只是一些小功能。

dump(); is basically like phps var_dump() but has a better looking output that helps when looking into bigger objects or arrays.  
dump（）;基本上类似于phps var_dump（），但具有更好看的输出，有助于查看更大的对象或数组。

dd() on the other hand is a function that dumps its parameters and then exits the php-script.  
dd（）是一个转储参数然后退出php脚本的函数。

you could just write dd($whoops) somewhere in your bootstrap.php to check how the output looks.  
你可以在你的bootstrap.php中的某个地方写dd（$whoops）来检查输出的样子。

#### [](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/04-development-helpers.md#composer-scripts)Composer scripts 编写器脚本

now we have a few commands that are available on the command line. I personally do not like to type complex commands with lots of parameters by hand all the time, so I added a few lines to my `composer.json`:  
现在我们有几个命令可以在命令行上使用。我个人不喜欢总是手工输入带有大量参数的复杂命令，所以我在我的 `composer.json` 中添加了几行：

```json
"scripts": {
    "serve": [
      "Composer\\Config::disableProcessTimeout",
      "php -S 0.0.0.0:1235 -t public"       
    ],
    "phpstan": "./vendor/bin/phpstan analyze",
    "baseline": "./vendor/bin/phpstan analyze --generate-baseline",
    "check": "./vendor/bin/ecs",
    "fix": "./vendor/bin/ecs --fix",
    "rector": "./vendor/bin/rector process"
},
```

that way I can just type "composer" followed by the command name in the root of my project. if I want to start the php dev server I can just type "composer serve" and don't have to type in the hostname, port and target directory all the time.  
这样我就可以在项目的根目录中输入“composer”，然后输入命令名。如果我想启动php dev服务器，我可以只输入“composer serve”，而不必一直输入主机名，端口和目标目录。

You could also configure PhpStorm to automatically run these commands in the background and highlight the violations directly in the file you are currently editing. I personally am not a fan of this approach because it often disrupts my flow when programming and always forces me to be absolutely strict even if I am only trying out an idea for debugging.  
您还可以配置PhpStorm在后台自动运行这些命令，并直接在当前编辑的文件中突出显示违规。我个人并不是这种方法的粉丝，因为它经常在编程时扰乱我的流程，并且总是迫使我绝对严格，即使我只是在尝试调试的想法。

My workflow is to just write my code the way I currently feel and that execute the phpstan and the fix scripts before committing and pushing the code. There is a [highly opiniated blogpost](https://tomasvotruba.com/blog/2019/06/24/do-you-use-php-codesniffer-and-php-cs-fixer-phpstorm-plugin-you-are-slow-and-expensive/) discussing that topic further. That you can read. But in the end it boils down to what you are most comfortable with.  
我的工作流程是按照我目前的感觉编写代码，并在提交和推送代码之前执行phpstan和修复脚本。有一个非常固执己见的博客文章进一步讨论了这个话题。你能读懂。但最终它归结为你最舒服的。

### HTTP

PHP already has a few things built in to make working with HTTP easier. For example there are the [superglobals](http://php.net/manual/en/language.variables.superglobals.php) that contain the request information.  
PHP已经内置了一些东西，使使用HTTP更容易。例如，有包含请求信息的超全局变量。

These are good if you just want to get a small script up and running, something that won't be hard to maintain. However, if you want to write clean, maintainable, [SOLID](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) code, then you will want a class with a nice object-oriented interface that you can use in your application instead.  
如果您只想启动并运行一个小脚本，并且维护起来并不难，那么这些都是很好的选择。然而，如果你想写干净的、可维护的、SOLID代码，那么你需要一个具有良好的面向对象接口的类，你可以在你的应用程序中使用它。

Fortunately for us there has been a standard developed in the PHP-Community that is adopted by several Frameworks. The standard is called [PSR-7](https://www.php-fig.org/psr/psr-7/) and has several interfaces defined that a lot of php projects implement. This makes it easier for us to use modules developed for other frameworks in our projects.  
幸运的是，PHP社区已经开发了一个标准，被几个框架采用。该标准被称为PSR-7，并定义了许多PHP项目实现的接口。这使得我们更容易在我们的项目中使用为其他框架开发的模块。

As this is a widely adopted standard there are already several implementations available for us to use. I will choose the laminas/laminas-diactoros package as i am an old time fan of the laminas (previously zend) project.  
由于这是一个广泛采用的标准，已经有几个实现可供我们使用。我会选择laminas/laminas-diactoros包，因为我是laminas（以前的zend）项目的老粉丝。

Some alternatives are [slim-psr7](https://github.com/slimphp/Slim-Psr7), [Guzzle](https://github.com/guzzle/psr7) and a [lot more](https://packagist.org/providers/psr/http-message-implementation) are available for you to choose from.  
一些替代品是苗条的psr7，Guzzle和更多的可供您选择。

Symfony ships its own Request and Response objects that do not implement the psr-7 interfaces. Therefore, I will not use that in this tutorial, but if you understand how the psr-7 interfaces work you should have no problem in understanding the [symfony http-foundation](https://symfony.com/doc/current/components/http_foundation.html#request).  
Symfony提供了自己的请求和响应对象，这些对象没有实现psr—7接口。因此，我不会在本教程中使用它，但如果你理解psr—7接口的工作原理，你应该没有问题理解symfony http—foundation。

to install the laminas psr-packages just type `composer require laminas/laminas-diactoros` into your console and hit enter  
要安装laminas psr—packages，只需在控制台中键入 `composer require laminas/laminas-diactoros` 并按Enter

Now you can add the following below your error handler code in your `Bootstrap.php` (and don't forget to remove the exception):  
现在，您可以在 `Bootstrap.php` 中的错误处理程序代码下面添加以下内容（不要忘记删除异常）：

```php
$request = \Laminas\Diactoros\ServerRequestFactory::fromGlobals();
$response = new \Laminas\Diactoros\Response;
$response->getBody()->write('Hello World! ');
$response->getBody()->write('The Uri is: ' . $request->getUri()->getPath());
```

This sets up the `Request` and `Response` objects that you can use in your other classes to get request data and send a response back to the browser.  
这将设置您可以在其他类中使用的 `Request` 和 `Response` 对象，以获取请求数据并将响应发送回浏览器。

In order to actually add content to the response you have to access the body stream object of the Response and use the write()-Method on that object.  
为了实际向响应添加内容，您必须访问Response的主体流对象，并在该对象上使用write（）—方法。

To actually send something back, you will also need to add the following snippet at the end of your `Bootstrap.php` file:  
要实际发送回某些内容，您还需要在 `Bootstrap.php` 文件的末尾添加以下代码段：

```php
echo $response->getBody();
```

This will send the response data to the browser. If you don't do this, nothing happens as the `Response` object only stores data.  
这将向浏览器发送响应数据。如果你不这样做，什么也不会发生，因为 `Response` 对象只存储数据。

You can play around with the other methods of the Request object and take a look at its content with the dd() function.  
您可以尝试使用Request对象的其他方法，并使用dd（）函数查看其内容。

```php
dd($response)
```

Something you have to keep in mind is that the Response and Request objects are Immutable which means that they cannot be changed after creation. Whenever you want to modify a property you have to call one of the "with" functions, which creates a copy of the request object with the changed property and returns that clone:  
你必须记住的是，响应和请求对象是不可变的，这意味着它们在创建后不能被更改。每当你想修改一个属性时，你必须调用一个“with”函数，它会创建一个带有更改后的属性的请求对象的副本，并返回该副本：

```php
$response = $response->withStatus(200);
$response = $response->withAddedHeader('Content-type', 'application/json');
```

If you have ever struggled with Mutation-problems in an DateTime-Object you might understand why the standard has been defined this way.  
如果你曾经在DateTime-Object中遇到过突变问题，你可能会理解为什么标准是这样定义的。

But if you have been keeping attention you might argue that the following line should not work if the request object is immutable.  
但是如果你一直在关注，你可能会说如果请求对象是不可变的，下面这行就不应该工作。

```php
$response->getBody()->write('Hello World!');
```

The response-body implements a stream interface which is immutable for some reasons that are described in the [meta-document](https://www.php-fig.org/psr/psr-7/meta/#why-are-streams-mutable). For me the important thing is to be aware of the problems that can occur with mutable objects. Here is a small [Blogpost](http://andrew.carterlunn.co.uk/programming/2016/05/22/psr-7-is-not-immutable.html) that gives some context. Beware that the Middleware-Example in the post is based on a deprecated middleware standard. But more on middlewares will be discussed in later chapters. I, for one, am happy about that fact, as it saves me from writing at least 3 lines of code whenever i want to add content to a response object.  
响应体实现了一个流接口，由于元文档中描述的某些原因，该接口是不可变的。对我来说，重要的是要意识到可变对象可能发生的问题。这里有一个小博客，提供了一些背景。请注意，文章中的中间件示例是基于一个已弃用的中间件标准。但更多关于中间件的内容将在后面的章节中讨论。对于我来说，我很高兴这一事实，因为每当我想向响应对象添加内容时，它可以节省我至少3行代码。

```php
$body = $response->getBody();
$body->write('Hello World!');
$response = $response->withBody($body);
```

Right now we are just outputting the Response-Body without any headers or http-status. So we need to expand our output-logic a little more. Replace the line that echos the response-body with the following:  
现在我们只是输出没有任何头或http-status的响应体。因此，我们需要将我们的输出逻辑再扩展一点。将响应体的行替换为以下内容：

```php
foreach ($response->getHeaders() as $name => $values) {
    $first = strtolower($name) !== 'set-cookie';
    foreach ($values as $value) {
        $header = sprintf('%s: %s', $name, $value);
        header($header, $first);
        $first = false;
    }
}

$statusLine = sprintf(
    'HTTP/%s %s %s',
    $response->getProtocolVersion(),
    $response->getStatusCode(),
    $response->getReasonPhrase()
);
header($statusLine, true, $response->getStatusCode());

echo $response->getBody();
```

This code is still fairly simple and there is a lot more stuff that can be considered when emitting a response to a browser, if you want a more complete solution you can take a look at the [httpsoft/http-emitter](https://github.com/httpsoft/http-emitter/blob/master/src/SapiEmitter.php) package on github.  
这段代码仍然相当简单，在向浏览器发出响应时可以考虑更多的东西，如果你想要一个更完整的解决方案，你可以看看github上的httpsoft/http—emitter包。

Remember that the object is only storing data, so if you set multiple status codes before you send the response, only the last one will be applied.  
请记住，对象只存储数据，因此如果在发送响应之前设置了多个状态代码，则只应用最后一个状态代码。

Be sure to run composer phpstan, composer fix and composer check before moving on to the next chapter  
在进入下一章之前，请确保运行composer phpstan、composer fix和composer check

### Router 路由器

A router dispatches to different handlers depending on rules that you have set up.  
路由器根据您设置的规则分派到不同的处理程序。

With your current setup it does not matter what URL is used to access the application, it will always result in the same response. So let's fix that now.  
使用您当前的设置，无论使用什么URL访问应用程序，都将导致相同的响应。所以我们现在就解决这个问题。

I will use [nikic/fast-route](https://github.com/nikic/FastRoute) in this tutorial. But as always, you can pick your own favorite package.  
我将在本教程中使用nikic/fast-route。但一如既往，您可以选择自己最喜欢的套餐。

Alternative packages: [symfony/Routing](https://github.com/symfony/Routing), [Aura.Router](https://github.com/auraphp/Aura.Router), [fuelphp/routing](https://github.com/fuelphp/routing), [Klein](https://github.com/chriso/klein.php)  
替代软件包：symfony/Routing，Aura.Router，fuelphp/routing，Klein

By now you know how to install Composer packages, so I will leave that to you.  
到目前为止，您已经知道如何安装Composer包，所以我将把它留给您。

Now add this code block to your `Bootstrap.php` file where you added the 'hello world' message in the last chapter.  
现在将此代码块添加到您在上一章中添加'hello world'消息的 `Bootstrap.php` 文件中。

```php
$dispatcher = \FastRoute\simpleDispatcher(function (\FastRoute\RouteCollector $r) {
    $r->addRoute('GET', '/hello[/{name}]', function (\Psr\Http\Message\ServerRequestInterface $request) {
        $name = $request->getAttribute('name', 'Stranger');
        $response = (new \Laminas\Diactoros\Response)->withStatus(200);
        $response->getBody()->write('Hello ' . $name . '!');
        return $response;
    });
    $r->addRoute('GET', '/another-route', function (\Psr\Http\Message\ServerRequestInterface $request) {
        $response = (new \Laminas\Diactoros\Response)->withStatus(200);
        $response->getBody()->write('This works too!');
        return $response;
    });
});

$routeInfo = $dispatcher->dispatch(
    $request->getMethod(),
    $request->getUri()->getPath(),
);

switch ($routeInfo[0]) {
    case \FastRoute\Dispatcher::METHOD_NOT_ALLOWED:
        $response = (new \Laminas\Diactoros\Response)->withStatus(405);
        $response->getBody()->write('Method not allowed');
        $response = $response->withStatus(405);
        break;
    case \FastRoute\Dispatcher::FOUND:
        $handler = $routeInfo[1];
        foreach ($routeInfo[2] as $attributeName => $attributeValue) {
            $request = $request->withAttribute($attributeName, $attributeValue);
        }
        /** @var \Psr\Http\Message\ResponseInterface $response */
        $response = call_user_func($handler, $request);
        break;
    case \FastRoute\Dispatcher::NOT_FOUND:
    default:
        $response = (new \Laminas\Diactoros\Response)->withStatus(404);
        $response->getBody()->write('Not Found!');
        break;
}
```

In the first part of the code, you are registering the available routes for your application. In the second part, the dispatcher gets called and the appropriate part of the switch statement will be executed. If a route was found, we collect any variable parameters of the route, store them in the request parameterbag and call the handler callable. If the route dispatcher returns a wrong value in the first entry of the routeMatch array we handle it the same as a 404.  
在代码的第一部分中，您将为应用程序注册可用的路由。在第二部分中，调度程序被调用，switch语句的相应部分将被执行。如果找到了路由，我们收集路由的任何可变参数，将它们存储在请求参数包中，并调用处理程序可调用。如果路由调度器在routeMatch数组的第一个条目中返回错误的值，我们将其处理为404。

This setup might work for tiny applications, but once you start adding a few routes your bootstrap file will quickly get cluttered. So let's move them out into a separate file.  
这种设置可能适用于小型应用程序，但一旦你开始添加一些路由，你的引导文件很快就会变得混乱。所以我们把它们移到一个单独的文件中。

Create a new directory in you project root named 'config' and add a 'routes.php' file with the following content;  
在你的项目根目录下创建一个名为“config”的新目录，并添加一个包含以下内容的“routes.php”文件;

```php
<?php declare(strict_types = 1);

return function(\FastRoute\RouteCollector $r) {
    $r->addRoute('GET', '/hello[/{name}]', function (\Psr\Http\Message\ServerRequestInterface $request) {
        $name = $request->getAttribute('name', 'Stranger');
        $response = (new \Laminas\Diactoros\Response)->withStatus(200);
        $response->getBody()->write('Hello ' . $name . '!');
        return $response;
    });
    $r->addRoute('GET', '/another-route', function (\Psr\Http\Message\ServerRequestInterface $request) {
        $response = (new Laminas\Diactoros\Response)->withStatus(200);
        $response->getBody()->write('This works too!');
        return $response;
    });
};
```

Now let's rewrite the route dispatcher part to use the `routes.php` file.  
现在让我们重写路由调度器部分，以使用 `routes.php` 文件。

```php
$routeDefinitionCallback = require __DIR__ . '/../config/routes.php';
$dispatcher = \FastRoute\simpleDispatcher($routeDefinitionCallback);
```

This is already an improvement, but now all the handler code is in the `routes.php` file. This is not optimal, so let's fix that in the next part.  
这已经是一个改进，但现在所有的处理程序代码都在 `routes.php` 文件中。这不是最佳的，所以让我们在下一部分中修复它。

Of course, we now need to add the 'config' folder to the configuration files of our dev helpers so that they can scan that directory as well.  
当然，我们现在需要将"config"文件夹添加到我们的开发助手的配置文件中，以便他们也可以扫描该目录。

### Dispatching to a Class

分派到班级

In this tutorial we won't implement [MVC (Model-View-Controller)](http://martinfowler.com/eaaCatalog/modelViewController.html). MVC can't be implemented properly in PHP anyway, at least not in the way it was originally conceived. If you want to learn more about this, read [A Beginner's Guide To MVC](http://blog.ircmaxell.com/2014/11/a-beginners-guide-to-mvc-for-web.html) and the followup posts.  
在本教程中，我们不会实现MVC（模型-视图-控制器）。MVC无论如何不能在PHP中正确实现，至少不能以最初设想的方式实现。如果你想了解更多，请阅读MVC初学者指南和后续文章。

So forget about MVC and instead let's worry about [separation of concerns](http://en.wikipedia.org/wiki/Separation_of_concerns).  
因此，忘掉MVC，让我们来关注关注点分离。

We will need a descriptive name for the classes that handle the requests. For this tutorial I will use `Handler`, other common names are 'Controllers' or 'Actions'.  
我们需要一个描述性的名称来描述处理请求的类。在本教程中，我将使用 `Handler` ，其他常用名称是'Controllers'或'Controllers'。

Create a new folder inside the `src/` folder with the name `Action`. In this folder we will place all our action classes. In there, create a `Hello.php` file.  
在 `src/` 文件夹中创建一个名为 `Action` 的新文件夹。在这个文件夹中，我们将放置所有的动作类。在这里，创建一个 `Hello.php` 文件。

```php
<?php declare(strict_types = 1);

namespace Lubian\NoFramework\Action;

final class Hello implements \Psr\Http\Server\RequestHandlerInterface
{
    public function handle(\Psr\Http\Message\ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
    {
        $name = $request->getAttribute('name', 'Stranger');
        $response = (new \Laminas\Diactoros\Response)->withStatus(200);
        $response->getBody()->write('Hello ' . $name . '!');
        return $response;
    }
}
```

You can see that we implement the [RequestHandlerInterface](https://github.com/php-fig/http-server-handler/blob/master/src/RequestHandlerInterface.php) that has a 'handle'-Method with requires a Request object as its parameter and returns a Response-object. For now this is fine, but we may have to change our approach later. In any way it is good to know about this interface as we will implement it in some other parts of our application as well. In order to use that Interface we have to require it with composer: `composer require psr/http-server-handler`.  
你可以看到我们实现了一个RequestHandlerInterface，它有一个""—Method，需要一个Request对象作为它的参数，并返回一个Response—object。目前这很好，但我们以后可能不得不改变我们的方法。无论如何，了解这个接口是很好的，因为我们也将在应用程序的其他部分实现它。为了使用这个接口，我们必须使用composer： `composer require psr/http-server-handler` 来请求它。

The autoloader will only work if the namespace of a class matches the file path and the file name equals the class name. At the beginning I defined `Lubian\NoFramework` as the root namespace of the application so this is referring to the `src/` folder.  
自动加载器仅在类的命名空间与文件路径匹配并且文件名与类名相等时才能工作。在开始的时候，我将 `Lubian\NoFramework` 定义为应用程序的根命名空间，所以这是指 `src/` 文件夹。

Now let's change the hello world route so that it calls your new class method instead of the closure. Change your `routes.php` to this:  
现在让我们更改hello world路由，以便它调用新的类方法而不是闭包。把你的 `routes.php` 改成：

```php
return function(\FastRoute\RouteCollector $r) {
    $r->addRoute('GET', '/hello[/{name}]', \Lubian\NoFramework\Action\Hello::class);
    $r->addRoute('GET', '/another-route', \Lubian\NoFramework\Action\Another::class);
};
```

Instead of a callable we are now passing the fully namespaced class identifier to the route-definition. I also declared the class 'Another' as the target for the second route, you can create it by copying the Hello.php file and changing the response to the one we defined for the second route.  
我们现在将完全命名空间的类标识符传递给路由定义，而不是可调用的。我还声明了类'Another'作为第二个路由的目标，您可以通过复制Hello.php文件并将响应更改为我们为第二个路由定义的响应来创建它。

To make this work, you will also have to do a small refactor to the routing part of the `Bootstrap.php`:  
要做到这一点，你还必须对 `Bootstrap.php` 的路由部分做一个小的重构：

```php
case \FastRoute\Dispatcher::FOUND:
     $handler = new $routeInfo[1];
     if (! $handler instanceof \Psr\Http\Server\RequestHandlerInterface) {
        throw new \Exception('Invalid Requesthandler');
     }
     foreach ($routeInfo[2] as $attributeName => $attributeValue) {
        $request = $request->withAttribute($attributeName, $attributeValue);
     }
    $response = $handler->handle($request);
    assert($response instanceof \Psr\Http\Message\ResponseInterface)
    break;
```

So instead of just calling a method you are now instantiating an object and then calling the method on it.  
所以，你现在不是只调用一个方法，而是实例化一个对象，然后调用它的方法。

Now if you visit `http://localhost:1235/` everything should work. If not, go back and debug.  
现在如果你访问 `http://localhost:1235/` ，一切都应该工作。如果没有，则返回并调试。

And of course don't forget to commit your changes.  
当然，不要忘记提交您的更改。

Something that still bothers me is the fact, that we do have classes for our Handlers, but the Error responses are still generated in the routing-matching section and not in special classes. Also, we have still left some cases to chance, for example if there is an error in creating our RequestHandler class or if the call to the 'handle' function fails. We still have our whoopsie error-handler, but I like to be more explicit in my control flow.  
仍然困扰我的是这样一个事实，我们确实有处理程序的类，但是错误响应仍然是在路由匹配部分生成的，而不是在特殊的类中。此外，我们仍然保留了一些偶然的情况，例如，如果在创建我们的RequestList类时出错，或者如果对'handle'函数的调用失败。我们仍然有一个糟糕的错误处理程序，但我希望在控制流中更加明确。

In order to do that we need to define some special Exceptions that we can throw and catch explicitly. Lets add a new Folder/Namespace to our src directory called Exceptions. And define the classes NotFound, MethodNotAllowed and InternalServerError. All three should extend phps Base Exception class.  
为了做到这一点，我们需要定义一些特殊的对象，我们可以显式地抛出和捕获。让我们添加一个新的文件夹/目录空间到我们的src目录称为目录。并定义NotFound、MethodNotAllowed和InternalServerError类。所有这三个都应该扩展phps Base Exception类。

Here is my NotFound.php for example.  
下面是我的NotFound.php示例。

```php
<?php

declare(strict_types=1);

namespace Lubian\NoFramework\Exception;

final class NotFound extends Exception{}
```

Use that example to create a MethodNotAllowedException.php and InternalServerErrorException.php as well.  
使用该示例还可以创建MethodNotAllowedException.php和InternalServerErrorException.php。

After you have created those we update our Router code to use the new Exceptions.  
在您创建这些之后，我们更新路由器代码以使用新的路由器。

```php
try {
    switch ($routeInfo[0]) {
        case Dispatcher::FOUND:
            $className = $routeInfo[1];
            $handler = new $className;
            assert($handler instanceof RequestHandlerInterface);
            foreach ($routeInfo[2] as $attributeName => $attributeValue) {
                $request = $request->withAttribute($attributeName, $attributeValue);
            }
            $response = $handler->handle($request);
            break;
        case Dispatcher::METHOD_NOT_ALLOWED:
            throw new MethodNotAllowed;

        case Dispatcher::NOT_FOUND:
        default:
            throw new NotFound;
    }
} catch (MethodNotAllowed) {
    $response = (new Response)->withStatus(405);
    $response->getBody()->write('Not Allowed');
} catch (NotFound) {
    $response = (new Response)->withStatus(404);
    $response->getBody()->write('Not Found');
} catch (Throwable $t) {
    throw new InternalServerError($t->getMessage(), $t->getCode(), $t);
}
```

Check if our code still works, try to trigger some errors, run phpstan and the fix command and don't forget to commit your changes.  
检查我们的代码是否还能工作，尝试触发一些错误，运行phpstan和fix命令，不要忘记提交你的修改。

### Inversion of Control 控制反转

In the last part you have set up a controller class and generated our Http-Response-object in that class, but if we want to switch to a more powerfull Http-Implementation later, or need to create our own for some special purposes, then we would need to edit every one of our request handlers to call a different constructor of the class.  
在最后一部分中，你已经建立了一个控制器类，并在该类中生成了我们的Http响应对象，但是如果我们以后想切换到一个更强大的Http实现，或者需要为某些特殊目的创建自己的Http实现，那么我们需要编辑我们的每一个请求处理程序来调用该类的不同构造函数。

The sane option is to use [inversion of control](http://en.wikipedia.org/wiki/Inversion_of_control). This means that instead of giving the class the responsibility of creating the object it needs, you just ask for them. This is done with [dependency injection](http://en.wikipedia.org/wiki/Dependency_injection).  
明智的选择是使用控制反转。这意味着，你只需请求它们，而不是让类负责创建它所需要的对象。这是通过依赖注入实现的。

If this sounds a little complicated right now, don't worry. Just follow the tutorial and once you see how it is implemented, it will make sense.  
如果现在听起来有点复杂，别担心。只要按照教程，一旦你看到它是如何实现的，它将是有意义的。

Change your `Hello` action to the following:  
将您的 `Hello` 操作更改为以下内容：

```php
<?php declare(strict_types = 1);

namespace Lubian\NoFramework\Action;

use Psr\Http\Server\RequestHandlerInterface;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface as Response;

final class Hello implements \Psr\Http\Server\RequestHandlerInterface;
{
    public function __construct(
        private Response $response
    ) {}
    public function handle(Request $request): Response
    {
        $name = $request->getAttribute('name', 'Stranger');
        $body = $this->response->getBody();

        $body->write('Hello ' . $name . '!');

        return $this->response
            ->withBody($body)
            ->withStatus(200);
    }
}
```

Now the code will result in an error because we are not actually injecting anything. So let's fix that in the `Bootstrap.php` where we dispatch when a route was found:  
现在代码将导致错误，因为我们实际上没有注入任何东西。因此，让我们在 `Bootstrap.php` 中解决这个问题，当找到路由时，我们会调度：

```php
$handler = new $className($response);
```

Of course we need to also update all the other handlers.  
当然，我们还需要更新所有其他处理程序。

### Dependency Injector 依赖注入

In the last chapter we rewrote our Actions to require the response-objet as a constructor parameter, and provided it in the dispatcher section of our `Bootstrap.php`. As we only have one dependency this works really fine, but if we have different classes with different dependencies our bootstrap file gets complicated quite quickly. Let's look at an example to explain the problem and work on a solution.  
在上一章中，我们重写了我们的Action，要求将response-objet作为构造函数参数，并在 `Bootstrap.php` 的dispatcher部分提供了它。因为我们只有一个依赖项，所以这很好，但是如果我们有不同的依赖项的不同类，我们的引导文件会很快变得复杂。让我们看一个例子来解释这个问题并解决它。

#### [](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/09-dependency-injector.md#adding-a-clock-service)Adding a clock service

添加时钟服务

Lets assume that we want to show the current time in our Hello action. We could easily just call use one of the many ways to get the current time directly in the handle-method, but let's create a separate class and interface for that so we can later configure and switch our implementation.  
假设我们想在Hello操作中显示当前时间。我们可以很容易地调用use方法来直接在方法中获取当前时间，但是让我们为它创建一个单独的类和接口，这样我们就可以在以后配置和切换我们的实现。

We need a new 'Service\Time' namespace, so lets first create the folder in our 'src' directory 'src/Service/Time'. There we place a Clock.php interface and a SystemClock.php implementation:  
我们需要一个新的'Service\Time'命名空间，所以让我们首先在'src'目录'src/Service/Time'中创建文件夹。在这里我们放置一个Clock.php接口和一个SystemClock.php实现：

The Clock.php interface:  
Clock.php接口：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Service\Time;

interface Clock
{
    public function now(): \DateTimeImmutable;
}
```

The Clock interface is modelled after the [proposed clock interface psr](https://github.com/php-fig/fig-standards/blob/master/proposed/clock.md) which may or may not one day be accepted as an official standard.  
时钟接口是仿照所提议的时钟接口psr，psr可能有一天会被接受为官方标准。

The SystemClock.php implementation:  
SystemClock.php实现：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Service\Time;

final class SystemClock implements Clock
{
    public function now(): \DateTimeImmutable
    {
        return new \DateTimeImmutable();
    }

}
```

Now we can require the Clock interface as a dependency in our controller and use it to display the current time.  
现在我们可以在控制器中要求Clock接口作为依赖项，并使用它来显示当前时间。

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Action;


use Lubian\NoFramework\Service\Time\Clock;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;

final class Hello implements RequestHandlerInterface
{
    public function __construct(
        private readonly ResponseInterface $response,
        private readonly Clock $clock
    )
    {
    }

    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        $name = $request->getAttribute('name', 'Stranger');
        $body = $this->response->getBody();

        $time = $this->clock->now()->format('H:i:s');

        $body->write('Hello ' . $name . '!<br />');
        $body->write('The Time is: ' . $time);

        return $this->response->withBody($body)
            ->withStatus(200);
    }
}
```

But if we try to access the corresponding route in the browser we get an error:  
但是，如果我们尝试在浏览器中访问相应的路由，我们会得到一个错误：

> Too few arguments to function Lubian\NoFramework\Action\Hello::__construct(), 1 passed in /home/lubiana/PhpstormProjects/no-framework/app/src/Bootstrap.php on line 62 and exactly 2 expected  
> /home/lubiana/PhpstormProjects/no-framework/app/src/Bootstrap.php第62行传入的参数太少，无法运行Lubian\NoFramework\Action\Hello：：__construct（），需要2个参数

Our current problem is, that we have two Actions defined, which both have different constructor requirements. That means, that we need to have some code in our Application, that creates our Action Objects and takes care of injection all the needed dependencies.  
我们目前的问题是，我们定义了两个Action，它们都有不同的构造函数需求。这意味着，我们需要在我们的应用程序中有一些代码，创建我们的动作对象，并负责注入所有需要的依赖关系。

This code is called a Dependency Injector. If you want you can read [this](https://afilina.com/learn/design/dependency-injection) great blogpost about that topic, which I highly recommend.  
这段代码称为Dependency Injector。如果你愿意，你可以阅读这个关于这个主题的伟大博客文章，我强烈推荐。

Lets build our own Dependency Injector to make our application work again.  
让我们构建自己的Dependency Injector来让我们的应用程序再次工作。

As a starting point we are going to take a look at the [Container Interface](https://www.php-fig.org/psr/psr-11/) that is widely adopted in the PHP-World.  
作为一个起点，我们将看看在PHP世界中广泛采用的容器接口。

#### [](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/09-dependency-injector.md#building-a-dependency-container)Building a dependency container

构建依赖容器

**Short Disclaimer:** *Although it would be fun to write our own great implementation of this interface with everything that is needed for modern php development I will take a shortcut here and implement very reduced version to show you the basic concept.*  
简短免责声明：虽然这将是有趣的，写我们自己的伟大实现这个接口的一切，是现代php开发所需要的，我将采取一个捷径，在这里实现非常简化的版本，以显示你的基本概念。

The `Psr\Container\ContainerIterface` defines two methods:  
`Psr\Container\ContainerIterface` 定义了两个方法：

- has($id): bool returns true if the container can provide a value for a given ID  
  has（$id）：如果容器可以为给定的ID提供值，则bool返回true
- get($id): mixed returns some kind of value that is registered in the container for the given ID  
  get（$id）：mixed返回在容器中为给定ID注册的某种值

I mostly define an Interface or a fully qualified classname as an ID. That way I can query the container for the Clock interface or an Action class and get an object of that class or an object implementing the given Interface.  
我通常定义一个Interface或一个完全限定的类名作为ID。这样我就可以在容器中查询Clock接口或Action类，并获得该类的对象或实现给定Interface的对象。

For the sake of this tutorial we will put a new file in our config folder that returns an anonymous class implementing the container-interface.  
在本教程中，我们将在config文件夹中放置一个新文件，该文件返回一个实现container-interface的匿名类。

In this class we will configure all services required for our application and make them accessible via the get($id) method.  
在这个类中，我们将配置应用程序所需的所有服务，并通过get（$id）方法访问它们。

Before we can implement the interface we need to install its definition with composer `composer require "psr/container:^1.0"`. now we can create a file with a Class that implements that interface.  
在我们实现接口之前，我们需要使用composer `composer require "psr/container:^1.0"` 安装它的定义。现在我们可以创建一个文件，其中包含实现该接口的Class。

`config/container.php`:

```php
<?php declare(strict_types=1);

return new class () implements \Psr\Container\ContainerInterface {

    private readonly array $services;

    public function __construct()
    {
        $this->services = [
            \Psr\Http\Message\ServerRequestInterface::class => fn () => \Laminas\Diactoros\ServerRequestFactory::fromGlobals(),
            \Psr\Http\Message\ResponseInterface::class => fn () => new \Laminas\Diactoros\Response(),
            \FastRoute\Dispatcher::class => fn () => \FastRoute\simpleDispatcher(require __DIR__ . '/routes.php'),
            \Lubian\NoFramework\Service\Time\Clock::class => fn () => new \Lubian\NoFramework\Service\Time\SystemClock(),
            \Lubian\NoFramework\Action\Hello::class => fn () => new \Lubian\NoFramework\Action\Hello(
                $this->get(\Psr\Http\Message\ResponseInterface::class),
                $this->get(\Lubian\NoFramework\Service\Time\Clock::class)
            ),
            \Lubian\NoFramework\Action\Other::class => fn () => new \Lubian\NoFramework\Action\Other(
                $this->get(\Psr\Http\Message\ResponseInterface::class)
            ),
        ];
    }

    public function get(string $id)
    {
        if (! $this->has($id)) {
            throw new class () extends \Exception implements \Psr\Container\NotFoundExceptionInterface {
            };
        }
        return $this->services[$id]();
    }

    public function has(string $id): bool
    {
        return array_key_exists($id, $this->services);
    }
};
```

Here I have declared a services array, that has a class- or interface name as the keys, and the values are short closures that return an Object of the defined class or interface. The `has` method simply checks if the given id is defined in our services array, and the `get` method calls the closure defined in the array for the given id key and then returns the result of that closure.  
这里我声明了一个服务数组，它有一个类或接口名作为键，值是短闭包，返回定义的类或接口的Object。 `has` 方法只是检查给定的id是否在我们的services数组中定义，而 `get` 方法调用数组中为给定id键定义的闭包，然后返回该闭包的结果。

To use the container we need to update our Bootstrap.php. Firstly we need to get an instance of our container, and then use that to create our Request-Object as well as the Dispatcher. So remove the manual instantiation of those objects and replace that with the following code:  
要使用容器，我们需要更新Bootstrap.php。首先，我们需要获取容器的实例，然后使用它来创建我们的请求对象以及Dispatcher。因此，请删除这些对象的手动实例化，并将其替换为以下代码：

```php
$container = require __DIR__ . '/../config/container.php';
assert($container instanceof \Psr\Container\ContainerInterface);

$request = $container->get(\Psr\Http\Message\ServerRequestInterface::class);
assert($request instanceof \Psr\Http\Message\ServerRequestInterface);

$dispatcher = $container->get(FastRoute\Dispatcher::class);
assert($dispatcher instanceof \FastRoute\Dispatcher);
```

In the Dispatcher switch block we manually build our handler object with this two lines:  
在Dispatcher switch块中，我们用这两行手动构建处理程序对象：

```php
$handler = new $className($response);
assert($handler instanceof RequestHandlerInterface);
```

Instead of manually creating the Handler-Instance we are going to kindly ask the Container to build it for us:  
我们不需要手动创建Handler-Instance，而是请Container为我们构建它：

```php
$handler = $container->get($className);
assert($handler instanceof RequestHandlerInterface);
```

If you now open the `/hello` route in your browser everything should work again!  
如果你现在在浏览器中打开 `/hello` 路由，一切都应该再次工作！

#### [](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/09-dependency-injector.md#using-auto-wiring)Using Auto wiring 使用自动布线

If you take a critical look at the services array you might see that we need to manually define how our Hello- and Other-Action are getting constructed. This is quite repetitive, as we have already declared what objects to create when asking for the ResponseInterface and the Clock-Interface. We would need to write way less code, if our Container was smart enough to automatically figure our which services to Inject by looking at the constructor of a class.  
如果您仔细查看服务数组，您可能会发现我们需要手动定义如何构造Hello-和Hello-Action。这是相当重复的，因为我们已经声明了在请求ResponseInterface和Clock-Interface时要创建什么对象。如果我们的容器足够聪明，可以通过查看类的构造函数来自动确定要注入哪些服务，那么我们需要编写的代码就更少了。

PHP provides us with the great Reflection Api that is capable of showing us, [what arguments a constructor of any given class requires](https://www.php.net/manual/de/reflectionclass.getconstructor.php). We could implement that functionality ourselves, or just try to use a library that takes care of that for us.  
PHP为我们提供了强大的Reflection API，它能够向我们展示任何给定类的构造函数需要哪些参数。我们可以自己实现这个功能，或者只是尝试使用一个库来为我们解决这个问题。

You can query the composer database to find all [libraries that implement the container interface](https://packagist.org/providers/psr/container-implementation).  
您可以查询composer数据库以查找实现容器接口的所有库。

I choose the [PHP-DI](https://packagist.org/packages/php-di/php-di) container, as it is easy to configure and provides some very [powerfull features](https://php-di.org/#autowiring) out of the box, and also solves the auto wiring problem.  
我选择PHP-DI容器，因为它易于配置，并提供了一些非常强大的开箱即用的特性，还解决了自动布线问题。

Let's rewrite our `container.php` file to use the PHP-DI container and only define the Services the Container cannot automatically build.  
让我们重写我们的 `container.php` 文件以使用PHP-DI容器，并只定义容器不能自动构建的服务。

```php
<?php declare(strict_types=1);

$builder = new \DI\ContainerBuilder;

$builder->addDefinitions([
    \Psr\Http\Message\ServerRequestInterface::class => fn () => \Laminas\Diactoros\ServerRequestFactory::fromGlobals(),
    \Psr\Http\Message\ResponseInterface::class => fn () => new \Laminas\Diactoros\Response(),
    \FastRoute\Dispatcher::class => fn () => \FastRoute\simpleDispatcher(require __DIR__ . '/routes.php'),
    \Lubian\NoFramework\Service\Time\Clock::class => fn () => new \Lubian\NoFramework\Service\Time\SystemClock(),
]);

return $builder->build();
```

As the PHP-DI container that is return by the `$builder->build()` method implements the same container interface as our previously used ad-hoc container we won't need to update the Bootstrap file and everything still works.  
由于 `$builder->build()` 方法返回的PHP-DI容器实现了与我们以前使用的ad-hoc容器相同的容器接口，因此我们不需要更新Bootstrap文件，一切都仍然有效。

### Invoker 调用程序

Currently, all our Actions need to implement the RequestHandlerInterface, which forces us to accept the Request as the one and only argument to our handle function, but most of the time we only need a few attributes in our Action a long with some services and not the whole Request object with all its various properties.  
目前，我们所有的Action都需要实现RequestHandlerInterface，这迫使我们接受Request作为handle函数的唯一参数，但大多数时候，我们只需要Action中的一些属性，而不是整个Request对象及其各种属性。

If we take our Hello action for example we only need a response object, the clock service and the 'name' information from the request-uri. And as that class only provides one simple method we could easily make that invokable as we already named the class hello, and it would be redundant to also call the method hello. So an updated version of that class could look like this:  
如果我们以Hello操作为例，我们只需要一个响应对象、时钟服务和来自request—uri的"name"信息。由于这个类只提供了一个简单的方法，我们可以很容易地使它可调用，因为我们已经将类命名为hello，并且还调用方法hello是多余的。所以这个类的更新版本可能看起来像这样：

```php
final class Hello
{
    public function __invoke(
        ResponseInterface $response,
        Clock $clock,
        string $name = 'Stranger'
    ): ResponseInterface
    {
        $body = $response->getBody();

        $body->write('Hello ' . $name . '!<br />');
        $body->write('The time is: ' . $clock->now()->format('H:i:s'));

        return $response->withBody($body)
            ->withStatus(200);
    }
}
```

It would also be neat if we could define a classname plus a method as target handler in our routes, or even a short closure function if we want to redirect all requests from '/' to '/hello' because we have not defined a handler for the root path of our application yet.  
如果我们可以在路由中定义一个类名和一个方法作为目标处理程序，或者如果我们想将所有请求从'/'重定向到'/hello'，甚至是一个简短的闭包函数，因为我们还没有为应用程序的根路径定义一个处理程序。

```php
$r->addRoute('GET', '/hello[/{name}]', Hello::class);
$r->addRoute('GET', '/other-route', [Other::class, 'handle']);
$r->addRoute('GET', '/', fn (Response $r) => $r->withStatus(302)->withHeader('Location', '/hello'));
```

In order to support this crazy route definitions we would need to write a lot of code for actually calling the result of the route dispatcher. If the result is a name of an invokable class we would use the container to create an instance of that class for us and then use the [reflection api](https://www.php.net/manual/en/book.reflection.php) to figure out what arguments the __invoke function has, try to fetch all arguments from the container and then add some more from the router if they are needed and available. The same if we have an array of a class name with a function to call, and for a simple callable we would need to manually use reflection as well to resolve all the arguments.  
为了支持这种疯狂的路由定义，我们需要编写大量的代码来实际调用路由调度器的结果。如果结果是一个可调用类的名称，我们将使用容器为我们创建该类的实例，然后使用反射API来确定__invoke函数有哪些参数，尝试从容器中获取所有参数，然后在需要和可用时从路由器添加更多参数。同样的，如果我们有一个类名的数组和一个要调用的函数，对于一个简单的可调用对象，我们也需要手动使用反射来解析所有的参数。

But we are quite lucky as the PHP-DI container provides us with a [great 'call' method](https://php-di.org/doc/container.html#call) which handles all of that for us.  
但是我们很幸运，因为PHP-DI容器为我们提供了一个很好的“call”方法，它为我们处理了所有这些。

After you added the described changes to your routes file you can modify the Dispatcher::FOUND case of you $routeInfo switch section in the Bootstrap.php file to use the container->call() method:  
在你将上述修改添加到你的routes文件中之后，你可以修改Bootstrap.php文件中你$routeInfo开关部分的Dispatcher：：FOUND case来使用container->call（）方法：

```php
$handler = $routeInfo[1];
$args = $routeInfo[2];
foreach ($routeInfo[2] as $attributeName => $attributeValue) {
    $request = $request->withAttribute($attributeName, $attributeValue);
}
$args['request'] = $request;
$response = $container->call($handler, $args);
```

Try to open [localhost:1235/](http://localhost:1235/) in your browser and check if you are getting redirected to '/hello'.  
尝试在浏览器中打开localhost：1235/，并检查是否重定向到“/hello’。

But by now you should know that I do not like to depend on specific implementations and the call method is not defined in the psr/container interface. Therefore, we would not be able to use that if we are ever switching to the symfony container or any other implementation.  
但是到现在为止，你应该知道我不喜欢依赖于特定的实现，并且调用方法没有在psr/container接口中定义。因此，如果我们切换到symfony容器或任何其他实现，我们将无法使用它。

Fortunately for us (or me) the PHP-CI container ships that function as its own class that is independent of the specific container implementation, so we could use it with any container that implements the ContainerInterface. And best of all the class ships with its own [Interface](https://github.com/PHP-DI/Invoker/blob/master/src/InvokerInterface.php) that we could implement if we ever want to write our own implementation, or we could write an adapter that uses a different class that solves the same problem.  
幸运的是，对于我们（或我）来说，PHP-CI容器作为独立于特定容器实现的自己的类运行，因此我们可以将其与实现ContainerInterface的任何容器一起使用。最棒的是，类附带了自己的接口，如果我们想编写自己的实现，我们可以实现它，或者我们可以编写一个适配器，它使用不同的类来解决相同的问题。

But for now we are using the solution provided by PHP-DI. So lets request a Service implementing the InvokerInterface from the container and use that inside of the switch-case block  
但是现在我们使用的是PHP-DI提供的解决方案。因此，让我们从容器中请求一个实现了BokerInterface的Service，并在switch-case块中使用它

```php
$handler = $routeInfo[1];
$args = $routeInfo[2] ?? [];
foreach ($routeInfo[2] as $attributeName => $attributeValue) {
    $request = $request->withAttribute($attributeName, $attributeValue);
}
$args['request'] = $request;
$invoker = $container->get(InvokerInterface::class);
assert($invoker instanceof InvokerInterface);
$response = $invoker->call($handler, $args);
assert($response instanceof ResponseInterface);
```

Now we are able to define absolutely everything in routes that is considered a [callable](https://www.php.net/manual/de/language.types.callable.php) by php, and even some more.  
现在我们可以定义路由中所有被php认为是可调用的东西，甚至更多。

But let us move on to something more fun and add some templating functionality to our application as we are trying to build a website in the end.  
但是，让我们继续做一些更有趣的事情，在我们最终试图构建一个网站时，为我们的应用程序添加一些模板功能。

### Templating 模板

A template engine is not necessary with PHP because the language itself can take care of that. But it can make things like escaping values easier. They also make it easier to draw a clear line between your application logic and the template files which should only put your variables into the HTML code.  
PHP不需要模板引擎，因为语言本身可以解决这个问题。但它可以使转义值等事情变得更容易。它们还可以更容易地在应用程序逻辑和模板文件之间划清界限，这些模板文件只应该将变量放入HTML代码中。

A good quick read on this is [ircmaxell on templating](http://blog.ircmaxell.com/2012/12/on-templating.html). Please also read [this](http://chadminick.com/articles/simple-php-template-engine.html) for a different opinion on the topic. Personally I don't have a strong opinion on the topic, so decide yourself which approach works better for you.  
一个很好的快速阅读这是ircmaxell的模板。也请阅读这篇文章，了解关于这个话题的不同观点。就我个人而言，我对这个话题没有强烈的看法，所以你自己决定哪种方法更适合你。

For this tutorial we will use a PHP implementation of [Mustache](https://github.com/bobthecow/mustache.php). So install that package before you continue (`composer require mustache/mustache`).  
在本教程中，我们将使用Mustache的PHP实现。所以在继续之前安装该软件包（ `composer require mustache/mustache` ）。

Another well known alternative would be [Twig](http://twig.sensiolabs.org/).  
另一个众所周知的替代品是Twig。

Now please go and have a look at the source code of the [engine class](https://github.com/bobthecow/mustache.php/blob/master/src/Mustache/Engine.php). As you can see, the class does not implement an interface.  
现在请去看看引擎类的源代码。正如你所看到的，这个类没有实现接口。

You could just type hint against the concrete class. But the problem with this approach is that you create tight coupling.  
你可以在具体的类中输入hint。但这种方法的问题是，您创建了紧耦合。

In other words, all your code that uses the engine will be coupled to this mustache package. If you want to change the implementation you have a problem. Maybe you want to switch to Twig, maybe you want to write your own class or you want to add functionality to the engine. You can't do that without going back and changing all your code that is tightly coupled.  
换句话说，所有使用该引擎的代码都将耦合到这个mustache包。如果你想改变实现，你就有问题了。也许你想切换到Twig，也许你想写自己的类，或者你想给引擎添加功能。如果不返回并更改所有紧耦合的代码，就无法做到这一点。

What we want is loose coupling. We will type hint against an interface and not a class/implementation. So if you need another implementation, you just implement that interface in your new class and inject the new class instead.  
我们想要的是松耦合。我们将针对接口而不是类/实现输入hint。因此，如果需要另一个实现，只需在新类中实现该接口并注入新类即可。

Instead of editing the code of the package we will use the [adapter pattern](http://en.wikipedia.org/wiki/Adapter_pattern). This sounds a lot more complicated than it is, so just follow along.  
我们将使用适配器模式，而不是编辑包的代码。这听起来比实际情况复杂得多，所以只要跟着沿着。

First let's define the interface that we want. Remember the [interface segregation principle](http://en.wikipedia.org/wiki/Interface_segregation_principle). This means that instead of large interfaces with a lot of methods we want to make each interface as small as possible. A class can implement multiple interfaces if necessary.  
首先让我们定义我们想要的接口。记住界面隔离原则。这意味着，我们希望每个接口尽可能小，而不是有很多方法的大接口。如果需要，一个类可以实现多个接口。

So what does our template engine actually need to do? For now we really just need a simple `render` method. Create a new folder in your `src/` folder with the name `Template` where you can put all the template related things.  
那么我们的模板引擎实际上需要做什么呢？现在我们只需要一个简单的 `render` 方法。在 `src/` 文件夹中创建一个新文件夹，名称为 `Template` ，您可以将所有模板相关的东西放在其中。

In there create a new interface `Renderer.php` that looks like this:  
在这里创建一个新的接口 `Renderer.php` ，看起来像这样：

```php
<?php declare(strict_types = 1);

namespace Lubian\NoFramework\Template;

interface Renderer
{
    /** @param array<string, mixed> $data */
    public function render(string $template, array $data = []): string;
}
```

Now that this is sorted out, let's create the implementation for mustache. In the same folder, create the file `MustacheRenderer.php` with the following content:  
既然已经解决了这个问题，让我们来创建mustache的实现。在同一文件夹中，创建文件 `MustacheRenderer.php` ，内容如下：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Template;

final class MustacheRenderer implements Renderer
{
    public function __construct(private \Mustache_Engine $engine){}

    public function render(string $template, array $data = []): string
    {
        return $this->engine->render($template, $data);
    }
}
```

As you can see the adapter is really simple. While the original class had a lot of methods, our adapter is really simple and only fulfills the interface.  
正如你所看到的，适配器非常简单。虽然原始类有很多方法，但我们的适配器非常简单，只实现接口。

Of course we also have to add a definition in our `dependencies.php` file because otherwise the container won't know which implementation he has to inject when you hint for the interface. Add this line:  
当然，我们还必须在我们的 `dependencies.php` 文件中添加一个定义，因为否则当你提示接口时，容器将不知道他必须注入哪个实现。添加这一行：

```php
[
   ...
   \Lubian\NoFramework\Template\Renderer::class => DI\create(\Lubian\NoFramework\Template\MustacheRenderer::class)
        ->constructor(new Mustache_Engine),
]
```

Now update the Hello.php class to require an implementation of our renderer interface and use that to render a string using mustache syntax.  
现在更新Hello.php类，要求实现我们的渲染器接口，并使用它来使用mustache语法渲染字符串。

```php
final class Hello
{
    public function __invoke(
        ResponseInterface $response,
        Now $now,
        Renderer $renderer,
        string $name = 'Stranger',
    ): ResponseInterface {
        $body = $response->getBody();
        $data = [
            'now' => $now()->format('H:i:s'),
            'name' => $name,
        ];

        $content = $renderer->render(
            'Hello {{name}}, the time is {{now}}!',
            $data,
        );

        $body->write($content);

        return $response
            ->withStatus(200)
            ->withBody($body);
    }
}
```

Now go check quickly in your browser if everything works. By default Mustache uses a simple string handler. But what we want is template files, so let's go back and change that.  
现在去快速检查您的浏览器，如果一切正常。默认情况下，Mustache使用一个简单的字符串处理程序。但是我们想要的是模板文件，所以让我们回过头来改变它。

To make this change we need to pass an options array to the `Mustache_Engine` constructor. So let's go back to the `dependencies.php` file and add the following code:  
要进行此更改，我们需要向 `Mustache_Engine` 构造函数传递一个选项数组。所以让我们回到 `dependencies.php` 文件并添加以下代码：

```php
[
    ...
    Mustache_Loader_FilesystemLoader::class => fn() => new Mustache_Loader_FilesystemLoader(__DIR__ . '/../templates', ['extension' => '.html']),
    Mustache_Engine::class => fn (Mustache_Loader_FilesystemLoader $MLFsl) => new Mustache_Engine(['loader' => $MLFsl]),
]
```

We are passing an options array because we want to use the `.html` extension instead of the default `.mustache` extension. Why? Other template languages use a similar syntax and if we ever decide to change to something else then we won't have to rename all the template files.  
我们传递一个选项数组，因为我们希望使用 `.html` 扩展名而不是默认的 `.mustache` 扩展名。为什么？其他模板语言使用类似的语法，如果我们决定更改为其他语言，那么我们不必重命名所有模板文件。

To let PHP-DI use its magic for creating our MustacheRenderer class we need to tell it exactly how to wire all the dependencies, therefore I defined how to create the Filesystemloader, on the next line we typehinted that loader in the short closure which acts as a factory method for the Mustache_Engine, as PHP-DI automatically injects the Object we can then use it in the factory.  
为了让PHP-DI使用它的魔力来创建我们的MustacheRenderer类，我们需要告诉它如何连接所有的依赖项，因此我定义了如何创建Filesystemloader，在下一行中，我们在短闭包中输入了loader，它充当Mustache_Engine的工厂方法，因为PHP-DI会自动注入Object，然后我们可以在工厂中使用它。

In your project root folder, create a `templates` folder. In there, create a file `hello.html`. The content of the file should look like this:  
在项目根文件夹中，创建一个 `templates` 文件夹。在这里，创建一个文件 `hello.html` 。文件的内容应该如下所示：

```text
<h1>Hello {{name}}</h1>
<p>The time is: {{time}}</p>
```

Now you can go back to your `Hello` action and change the render line to `$html = $this->renderer->render('hello', $data);`  
现在你可以回到你的 `Hello` 操作，并将渲染行改为 `$html = $this->renderer->render('hello', $data);`

Navigate to the hello page in your browser to make sure everything works.  
在浏览器中导航到hello页面，以确保一切正常。

Before you move on to the next chapter be sure to run our quality tools and commit your changes.  
在进入下一章之前，请确保运行我们的质量工具并提交您的更改。

### Configuration 配置

In the last chapter we added some more definitions to our dependencies.php in that definitions we needed to pass quite a few configuration settings and filesystem strings to the constructors of the classes. This might work for a small projects, but if we are growing we want to source that out to a more explicit file that holds all the configuration values for our project.  
在上一章中，我们在dependencies.php中添加了更多的定义，我们需要将相当多的配置设置和文件系统字符串传递给类的构造函数。这可能适用于小项目，但如果我们正在增长，我们希望将其源代码输出到一个更明确的文件中，该文件包含我们项目的所有配置值。

As this is not a problem unique to our project there are already a some options available. Some projects use [.env](https://github.com/vlucas/phpdotenv) files, others use [.ini](https://www.php.net/manual/de/function.parse-ini-file.php), there is [yaml](https://www.php.net/manual/de/function.yaml-parse-file.php) as well some frameworks have implemented complex Readers for many configuration file formats that can be used, take a look at the [laminas config component](https://docs.laminas.dev/laminas-config/reader/) for example.  
由于这不是我们项目独有的问题，因此已经有一些可用的选项。有些项目使用.env文件，有些使用.ini，还有yaml，有些框架已经实现了复杂的Readers，可以使用许多配置文件格式，例如看看laminas config组件。

As I am a big fan of writing everything in php, which gives our IDE the chance to autocomplete our code better I am quite happy that PHP8 gives us some tools to achieve easy to use configuration via php. You can take a look at [this blogpost](https://stitcher.io/blog/what-about-config-builders) to read about some considerations on that topic before moving on.  
因为我是一个用php编写一切的超级粉丝，这让我们的IDE有机会更好地自动完成我们的代码，我很高兴PHP8为我们提供了一些工具来通过php实现易于使用的配置。在继续之前，你可以看看这篇博客文章，了解有关该主题的一些考虑因素。

For the purpose of this Tutorial I will use a simple ValueObject that has all our configuration values as properties. create a `Configuration.php` class in the `./src` folder:  
为了达到这个目的，我将使用一个简单的ValueObject，它将所有的配置值作为属性。在 `./src` 文件夹中创建一个 `Configuration.php` 类：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework;

final class Configuration
{
    public function __construct(
        public readonly string $environment = 'dev',
        public readonly string $routesFile = __DIR__ . '/../config/routes.php',
        public readonly string $templateDir = __DIR__ . '/../templates',
        public readonly string $templateExtension = '.html',
    ) {
    }
}
```

I am using a new Feature from PHP 8.1 here called [readonly properties](https://stitcher.io/blog/php-81-readonly-properties) to write a small valueobject without the need to write complex getters and setters. The linked article gives a great explanation on how they work. You can see, that I have added working default values for every configuration parameter. In my personal opinion, project should always have working default values without you needing to set up anything. This greatly improves usability and reduces errors.  
我在这里使用PHP 8.1中的一个名为readonly properties的新特性来编写一个小的valueobject，而不需要编写复杂的getter和setter。链接的文章给出了一个很好的解释他们如何工作。您可以看到，我为每个配置参数添加了工作默认值。在我个人看来，project应该总是有工作默认值，而不需要你设置任何东西。这大大提高了可用性并减少了错误。

We can now update our `container.php` file to use the configuration. Currently, the Mustache_Loader, as well as the Fastroute-Dispatcher use values that we have defined in our Configuration, lets update those definitions:  
我们现在可以更新我们的 `container.php` 文件以使用该配置。目前，Mustache_Loader以及Fastroute—Dispatcher使用我们在配置中定义的值，让我们更新这些定义：

```php
    Dispatcher::class => fn (Configuration $c) => simpleDispatcher(require $c->routesFile),
    Mustache_Loader_FilesystemLoader::class => fn (Configuration $c) => new Mustache_Loader_FilesystemLoader(
        $c->templateDir,
        [
            'extension' => $c->templateExtension,
        ]
    ),
```

Magically this is all we need to do, as the PHP-DI container knows that all constructor parameters of our configuration class have default values and can create the needed object on its own.  
神奇的是，这就是我们需要做的所有事情，因为PHP—DI容器知道我们配置类的所有构造函数参数都有默认值，并且可以自己创建所需的对象。

There is one small problem: If we want to change environment from `dev` to `prod` we would need to update the configuration class in the src directory. This is something we don't want to do on every deployment. So lets add a file in our `./config` directory called `settings.php` that returns a Configuration object.  
有一个小问题：如果我们想将环境从 `dev` 更改为 `prod` ，我们需要更新src目录中的配置类。这是我们不想在每次部署中都做的事情。因此，让我们在 `./config` 目录中添加一个名为 `settings.php` 的文件，该文件返回Configuration对象。

```php
<?php declare(strict_types=1);

return new \Lubian\NoFramework\Configuration(
    environment: 'prod',
);
```

here I am using a new feature called [named arguments](https://stitcher.io/blog/php-8-named-arguments). There is a lot of discussion on the topic of named arguments as some argue it creates unclean and unmaintainable code, but for simple value-objects I would argue that they are ok.  
这里我使用了一个新特性，叫做命名参数。关于命名参数的话题有很多讨论，因为有些人认为它会创建不干净和不可维护的代码，但对于简单的值对象，我认为它们是可以的。

We now need to add a line to our container to use the `settings.php` file to create the Configuration-object:  
我们现在需要在容器中添加一行代码，以使用 `settings.php` 文件来创建一个paragation-object：

```php
    \Lubian\NoFramework\Configuration::class => fn () => require __DIR__ . '/settings.php',
```

One small oversight to fix is in the registration of our error-handler in the bootstrap-file. There we read the environment with the getenv-method. Lets change the line:  
需要修正的一个小疏忽是在引导程序文件中注册错误处理程序。这里我们用getenv方法读取环境。让我们改变路线：

```php
$environment = getenv('ENVIRONMENT') ?: 'dev';
```

to:

```php
$config = require __DIR__ . '/../config/settings.php';
assert($config instanceof \Lubian\NoFramework\Configuration);
$environment = $config->environment;
```

Check if everything still works, run your code quality checks and commit the changes before moving on the next chapter. You might notice that phpstan throws an error as there is a documented violation missing. You can either regenerate the baseline, or simply remove that line from the `phpstan-baseline.neon` file.  
检查一切是否仍然有效，运行代码质量检查并在进入下一章之前提交更改。你可能会注意到phpstan抛出一个错误，因为缺少一个记录的违规。您可以重新生成基线，或者简单地从 `phpstan-baseline.neon` 文件中删除该行。

### Refactoring 重构

By now our Bootstrap.php file has grown quite a bit, and with the addition of our dependency container there is now no reason not to introduce a lot of classes and interfaces for all the that are happening in the bootstrap file. After all the bootstrap file should just set up the classes needed for the handling logic and execute them.  
到目前为止，我们的Bootstrap.php文件已经增长了很多，并且随着我们的依赖容器的增加，现在没有理由不为bootstrap文件中发生的所有事情引入大量的类和接口。毕竟引导文件应该只设置处理逻辑所需的类并执行它们。

At the bottom of our Bootstrap.php we have our Response-Emitter Logic, lets create an Interface and a class for that. As I am really lazy I just selected the code in PhpStorm, klicken on 'Refactor -> extract method' then selected the method and clicked on 'Refactor -> extract class'. I choose 'BasicEmitter' for the classname, changed the method to non static and extracted an interface.  
在我们的Bootstrap.php的底部，我们有我们的响应—可扩展逻辑，让我们创建一个接口和一个类。由于我真的很懒，我只是选择了在PhpStorm的代码，kllljon 'Refactor—> extract method'然后选择了方法，并点击了'Refactor—> extract class'。我选择了'BasicEstrom'作为类名，将方法更改为非静态并提取了一个接口。

'./src/Http/Emitter.php'  
'./ src/Http/Emitter.php '

```php
<?php

namespace Lubian\NoFramework\Service\Http;

use Psr\Http\Message\ResponseInterface;

interface Emitter
{
    public function emit(ResponseInterface $response, bool $withoutBody = false): void;
}
```

'./src/Http/BasicEmitter.php'  
'./ src/Http/BasicEmitter.php '

```php
<?php

declare(strict_types=1);

namespace Lubian\NoFramework\Service\Http;

use Psr\Http\Message\ResponseInterface;

final class BasicEmitter implements Emitter
{
    public function emit(ResponseInterface $response, bool $withoutBody = false): void
    {
        /** @var string $name */
        foreach ($response->getHeaders() as $name => $values) {
            $first = strtolower($name) !== 'set-cookie';
            foreach ($values as $value) {
                $header = sprintf('%s: %s', $name, $value);
                header($header, $first);
                $first = false;
            }
        }

        $statusLine = sprintf(
            'HTTP/%s %s %s',
            $response->getProtocolVersion(),
            $response->getStatusCode(),
            $response->getReasonPhrase()
        );
        header($statusLine, true, $response->getStatusCode());

        if ($withoutBody) {
            return;
        }
        echo $response->getBody();
    }
}
```

After registering the BasicEmitter to implement the Emitter interface in the dependencies file you can use the following code in the Bootstrap.php to emit the response:  
在注册BasicEclock以在依赖文件中实现Eclock接口之后，您可以在Bootstrap.php中使用以下代码来发出响应：

```php
/** @var Emitter $emitter */
$emitter = $container->get(Emitter::class);
$emitter->emit($response);
```

If at some point you need a [more advanced emitter](https://github.com/httpsoft/http-emitter), you could now easily write an adapter that implements your emitter interface and wraps that more advanced emitter  
如果在某些时候您需要一个更高级的发射器，那么现在可以轻松地编写一个适配器来实现您的发射器接口并包装该更高级的发射器

Now that we have our Emitter in a seperate class we need to take care of the big block that handles our routing and calling the routerhandler that in the passes the request to a function and gets the response.  
现在我们在一个单独的类中有了我们的Etradition，我们需要处理处理我们的路由和调用routerhandler的大块，它将请求传递给一个函数并获得响应。

For this to steps to be seperated we are going to create two more classes:  
为了将这些步骤分开，我们将创建两个以上的类：

1. a RouteDecorator, that finds the correct handler for the requests and adds its findings to the Request Object  
   一个RouteDecorator，它为请求找到正确的处理程序，并将其结果添加到请求对象中
2. A Requesthandler that implements the RequestHandlerInterface, gets the information for the request handler from the requestobject, fetches the correct object from the container and calls it to create a response.  
   实现RequestHandlerInterface的请求处理程序从requestobject获取请求处理程序的信息，从容器中获取正确的对象并调用它来创建响应。

Lets create the HandlerInterface first:  
首先创建HandlerInterface：

```php
<?php

declare(strict_types=1);

namespace Lubian\NoFramework\Service\Http;

use Psr\Http\Server\RequestHandlerInterface;

interface RoutedRequestHandler extends RequestHandlerInterface
{
    public function setRouteAttributeName(string $routeAttributeName = '__route_handler'): void;
}
```

By looking at the namespace and interfacename you should be able to figure out where to place the file and how to name it.  
通过查看名称空间和接口，您应该能够确定将文件放置在何处以及如何命名它。

We define a public function that the router can use to tell the handler which attribute name to look for in the request.  
我们定义了一个公共函数，路由器可以用它来告诉处理程序在请求中查找哪个属性名。

Now write an implementation that uses a container to satisfy the interface.  
现在编写一个使用容器来满足接口的实现。

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Http;

use Invoker\InvokerInterface;
use Lubian\NoFramework\Exception\InternalServerError;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

use function assert;

final class InvokerRoutedHandler implements RoutedRequestHandler
{
    public function __construct(
        private readonly InvokerInterface $invoker,
        private string $routeAttributeName = '__route_handler',
    ) {
    }

    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        $handler = $request->getAttribute($this->routeAttributeName, false);
        assert($handler !== false);
        $vars = $request->getAttributes();
        $vars['request'] = $request;
        $response = $this->invoker->call($handler, $vars);
        if (! $response instanceof ResponseInterface) {
            throw new InternalServerError('Handler returned invalid response');
        }
        return $response;
    }

    public function setRouteAttributeName(string $routeAttributeName = '__route_handler'): void
    {
        $this->routeAttributeName = $routeAttributeName;
    }
}
```

We will define our routing class to implement the MiddlewareInterface, you can install that with 'composer require psr/http-server-middleware'. The interface requires us to implement a method called 'process' a Request as its first argument and an RequestHandler as the second one. The return value of the method needs to be a Responseobject. We will learn more about Middlewares in the next chapter.  
我们将定义我们的路由类来实现MiddlewareInterface，你可以用“composer require psr/http-server-middleware”来安装它。这个接口要求我们实现一个叫做“process”的方法，一个Request作为它的第一个参数，一个RequestList作为第二个参数。方法的返回值必须是一个Responseobject。我们将在下一章学习更多关于中间件的知识。

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Http;

use FastRoute\Dispatcher;
use Lubian\NoFramework\Exception\InternalServerError;
use Lubian\NoFramework\Exception\MethodNotAllowed;
use Lubian\NoFramework\Exception\NotFound;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Throwable;

final class RouteMiddleware implements MiddlewareInterface
{
    public function __construct(
        private readonly Dispatcher $dispatcher,
        private readonly ResponseFactoryInterface $responseFactory,
        private readonly string $routeAttributeName = '__route_handler',
    ) {
    }

    private function decorateRequest(
        ServerRequestInterface $request,
    ): ServerRequestInterface {
        $routeInfo = $this->dispatcher->dispatch(
            $request->getMethod(),
            $request->getUri()->getPath(),
        );

        if ($routeInfo[0] === Dispatcher::METHOD_NOT_ALLOWED) {
            throw new MethodNotAllowed;
        }

        if ($routeInfo[0] === Dispatcher::FOUND) {
            foreach ($routeInfo[2] as $attributeName => $attributeValue) {
                $request = $request->withAttribute($attributeName, $attributeValue);
            }
            return $request->withAttribute(
                $this->routeAttributeName,
                $routeInfo[1]
            );
        }

        throw new NotFound;
    }

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        try {
            $request = $this->decorateRequest($request);
        } catch (NotFound) {
            $response = $this->responseFactory->createResponse(404);
            $response->getBody()->write('Not Found');
            return $response;
        } catch (MethodNotAllowed) {
            return $this->responseFactory->createResponse(405);
        } catch (Throwable $t) {
            throw new InternalServerError($t->getMessage(), $t->getCode(), $t);
        }

        if ($handler instanceof RoutedRequestHandler) {
            $handler->setRouteAttributeName($this->routeAttributeName);
        }
        return $handler->handle($request);
    }
}
```

Before we can use all the new services in our Bootstrap file we need to add the definitions to our container.  
在使用Bootstrap文件中的所有新服务之前，我们需要将定义添加到容器中。

```php
[
        '...',
        Emitter::class => fn (BasicEmitter $e) => $e,
        RoutedRequestHandler::class => fn (InvokerRoutedHandler $h) => $h,
        MiddlewareInterface::class => fn (RouteMiddleware $r) => $r,
        Dispatcher::class => fn (Settings $s) => simpleDispatcher(require __DIR__ . '/routes.php'),
        ResponseFactoryInterface::class => fn (ResponseFactory $rf) => $rf,
],
```

And then we can update our Bootstrap.php to fetch all the services and let them handle the request.  
然后我们可以更新Bootstrap.php来获取所有的服务并让它们处理请求。

```php
...
$routeMiddleWare = $container->get(MiddlewareInterface::class);
assert($routeMiddleWare instanceof MiddlewareInterface);
$handler = $container->get(RoutedRequestHandler::class);
assert($handler instanceof RequestHandlerInterface);
$emitter = $container->get(Emitter::class);
assert($emitter instanceof Emitter);

$request = $container->get(ServerRequestInterface::class);
assert($request instanceof ServerRequestInterface);

$response = $routeMiddleWare->process($request, $handler);
$emitter->emit($response);
```

Now we have wrapped all the important parts in our Bootstrap.php into seperate classes, but it is still quite a lot of code and also many calls the container (and i have to write way too many docblocks to that phpstan doenst yell at me).  
现在我们已经将Bootstrap.php中所有重要的部分都包装到了单独的类中，但是它仍然有很多代码，也有很多对容器的调用（我不得不写太多的docblock来让phpstan对我大喊大叫）。

So we should just add another class that wraps all of our Request-Handling Classes into a clearly defined structure.  
因此，我们应该添加另一个类，将所有的请求处理类包装到一个明确定义的结构中。

I will follow symfonys example and call this class our kernel. Before i create that class i will recap what our class should require to function properly.  
我将遵循symfonys的例子，并称这个类为我们的内核。在我创建这个类之前，我将回顾一下我们的类需要什么才能正常工作。

- A RequestFactory We want our Kernel to be able to build the request itself  
  一个RequestFactory我们希望我们的内核能够自己构建请求
- An Emitter Without an Emitter we will not be able to send the response to the client  
  如果没有一个ECONDER，我们将无法将响应发送到客户端
- RouteMiddleware To decore the request with the correct handler for the requested route  
  RouteMiddleware使用请求路由的正确处理程序对请求进行解密
- RequestHandler To delegate the request to the correct funtion that creates the response  
  将请求委托给创建响应的正确函数

As the Psr ContainerInterface leaves us to much handiwork to easily create a Serverrequest I will extend that interface to give us easier access to a requestobject and wrap the Diactorors RequestFactory in an Adapter that satisfies our interface:  
由于Psr ContainerInterface给我们留下了很多手工操作来轻松创建一个Serverrequest，我将扩展该接口以给予我们更容易访问requestobject并将Diactors RequestFactory包装在满足我们接口的Adapter中：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Factory;

use Psr\Http\Message\ServerRequestFactoryInterface;
use Psr\Http\Message\ServerRequestInterface;

interface RequestFactory extends ServerRequestFactoryInterface
{
    public function fromGlobals(): ServerRequestInterface;
}
```

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Factory;

use Laminas\Diactoros\ServerRequestFactory;
use Psr\Http\Message\ServerRequestInterface;

final class DiactorosRequestFactory implements RequestFactory
{
    public function __construct(private readonly ServerRequestFactory $factory)
    {
    }

    public function fromGlobals(): ServerRequestInterface
    {
        return $this->factory::fromGlobals();
    }

    public function createServerRequest(string $method, $uri, array $serverParams = []): ServerRequestInterface
    {
        return $this->factory->createServerRequest($method, $uri, $serverParams);
    }
}
```

For later shenanigans I will let our Kernel implement the RequestHandlerInterface, this is how my version looks now:  
对于后面的恶作剧，我将让我们的内核实现RequestHandlerInterface，这是我的版本现在的样子：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework;

use Lubian\NoFramework\Factory\RequestFactory;
use Lubian\NoFramework\Http\Emitter;
use Lubian\NoFramework\Http\RoutedRequestHandler;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

final class Kernel implements RequestHandlerInterface
{
    public function __construct(
        private readonly RequestFactory $requestFactory,
        private readonly MiddlewareInterface $routeMiddleware,
        private readonly RoutedRequestHandler $handler,
        private readonly Emitter $emitter,
    ) {
    }

    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        return $this->routeMiddleware->process($request, $this->handler);
    }

    public function run(): void
    {
        $request = $this->requestFactory->fromGlobals();
        $response = $this->handle($request);
        $this->emitter->emit($response);
    }
}
```

We can now replace everything after the ErrorHandler in our Bootstrap.php with these few lines  
我们现在可以用这几行代码替换Bootstrap.php中ErrorError之后的所有内容

```php
$app = $container->get(Kernel::class);
assert($app instanceof Kernel);

$app->run();
```

You might get some Errors here because the Container cannot resolve all the dependencies, try to fix those errors by looking at the Whoops output and adding the needed definitions to the dependencies.php file.  
你可能会在这里得到一些错误，因为容器无法解析所有的依赖项，尝试通过查看Whoops输出并将所需的定义添加到dependencies.php文件来修复这些错误。

And as always, don't forget to commit your changes.  
和往常一样，不要忘记提交您的更改。

### Middleware 中间件

In the last chapter we wrote our RouterClass to implement the middleware interface, and in this chapter I want to explain a bit more about what this interface does and why it is used in many applications.  
在上一章中，我们编写了RouterClass来实现中间件接口，在本章中，我想更多地解释一下这个接口的作用以及为什么它会在许多应用程序中使用。

The Middlewares are basically a number of wrappers that stand between the client and your application. Each request gets passed through all the middlewares, gets handled by our controllers and then the response gets passed back through all the middlewars to the client/emitter. You can check out [this Blogpost](https://doeken.org/blog/middleware-pattern-in-php) for a more in depth explanation of the middleware pattern.  
中间件基本上是一些位于客户机和应用程序之间的包装器。每个请求都通过所有的中间件，由我们的控制器处理，然后响应通过所有的中间件传递回客户端/发射器。您可以查看这篇博文，以获得对中间件模式的更深入的解释。

So every Middleware can modify the request before it goes on to the next middleware (and finally the handler) and the response after it gets created by our handlers.  
因此，每个中间件都可以在请求进入下一个中间件（最后是处理程序）之前修改请求，并在处理程序创建响应之后修改响应。

So lets take a look at the middleware and the requesthandler interfaces  
因此，让我们来看看中间件和请求处理程序接口

```php
interface MiddlewareInterface
{
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface;
}

interface RequestHandlerInterface
{
    public function handle(ServerRequestInterface $request): ResponseInterface;
}
```

The RequestHandlerInterface gets only a request and returns a response, the MiddlewareInterface gets a request and a requesthandler and returns a response. So the logical thing for the Middleware is to use the handler to produce the response.  
RequestHandlerInterface只获取一个请求并返回一个响应，MiddlewareInterface获取一个请求和一个请求处理程序并返回一个响应。因此，中间件的逻辑是使用处理程序来生成响应。

But the middleware could just ignore the handler and produce a response on its own as the interface just requires us to produce a response.  
但是中间件可以忽略处理程序并自己产生响应，因为接口只需要我们产生响应。

A simple example for that would be a caching middleware. The basic idea is that we want to cache all request from users that are not logged in. This way we can save a lot of processing power in rendering the html and fetching data from the database.  
一个简单的例子就是缓存中间件。基本的想法是，我们希望缓存所有来自未登录用户的请求。通过这种方式，我们可以保存大量的处理能力来渲染html和从数据库中获取数据。

In this scenario we assume that we have an authentication middleware that checks if a user is logged in and decorates the request with an 'isAuthenticated' attribute.  
在这个场景中，我们假设我们有一个身份验证中间件，它检查用户是否登录，并使用“isAuthenticated”属性装饰请求。

If the 'isAuthenticated' attribute is set to false, we check if we have a cached response and return that, if that response is not already cached, than we let the handler create the response and store that in the cache for a few seconds  
如果“isAuthenticated”属性设置为false，则检查是否有缓存的响应并返回，如果该响应尚未缓存，则让处理程序创建响应并将其存储在该高速缓存中几秒钟

```php
interface CacheInterface
{
    public function get(string $key, callable $resolver, int $ttl): mixed;
}
```

The first parameter is the identifier for the cache, the second is a callable that produces the value and the last one defines the seconds that the cache should keep the item. If the cache doesnt have an item with the given key then it uses the callable to produce the value and stores it for the time specified in ttl.  
第一个参数是该高速缓存的标识符，第二个参数是产生值的可调用项，最后一个参数定义了该高速缓存应该保留该项的秒数。如果该高速缓存没有具有给定键的项，则它使用可调用项来生成值，并将其存储到ttl中指定的时间。

so lets write our caching middleware:  
所以让我们编写缓存中间件：

```php
final class CachingMiddleware implements MiddlewareInterface
{
    public function __construct(private CacheInterface $cache){}
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        if ($request->getAttribute('isAuthenticated', false) && $request->getMethod() === 'GET') {
            $key = $request->getUri()->getPath();
            return $this->cache->get($key, fn() => $handler->handle($request), 10);
        }
        return $handler->handle($request);
    }
}
```

we can also modify the response after it has been created by our application, for example we could implement a gzip middleware, or for more simple and silly example a middleware that adds a Dank Meme header to all our response so that the browser know that our application is used to serve dank memes:  
我们也可以在应用程序创建响应后修改它，例如我们可以实现一个gzip中间件，或者更简单和愚蠢的例子是一个中间件，它将一个Dank Meme头部添加到我们所有的响应中，这样浏览器就知道我们的应用程序是用来提供dank meme的：

```php
final class DankMemeMiddleware implements MiddlewareInterface
{
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $response = $handler->handle($request);
        return $response->withAddedHeader('Meme', 'Dank');
    }
}
```

but for our application we are going to just add two external middlewares:  
但对于我们的应用程序，我们将只添加两个外部中间件：

- [Trailing-slash](https://github.com/middlewares/trailing-slash) to remove the trailing slash from all routes.  
  Trailing-slash用于删除所有路由中的尾随斜杠。
- [whoops middleware](https://github.com/middlewares/whoops) to wrap our error handler into a nice middleware  
  whoops中间件将错误处理程序包装到一个漂亮的中间件中

```bash
composer require middlewares/trailing-slash
composer require middlewares/whoops
```

The whoops middleware should be the first middleware to be executed so that we catch any errors that are thrown in the application as well as the middleware stack.  
whoops中间件应该是第一个被执行的中间件，这样我们就可以捕获应用程序和中间件堆栈中抛出的任何错误。

Our desired request -> response flow looks something like this:  
我们想要的请求->响应流看起来像这样：

```
        Client
        |     ^
        v     |
         Kernel
        |     ^
        v     |
     Whoops Middleware
        |     ^
        v     |
      TrailingSlash
        |     ^
        v     |
        Routing
        |     ^
        v     |
     ContainerResolver
        |     ^
        v     |
     Controller/Action
```

As every middleware expects a RequestHandlerInterface as its second argument we need some extra code that wraps every middleware as a RequestHandler and chains them together with the ContainerRouteDecoratedResolver as the last Handler.  
由于每个中间件都需要一个RequestHandlerInterface作为它的第二个参数，我们需要一些额外的代码来将每个中间件包装为一个RequestHandler，并将它们与ContainerRouteDecoratedResolver链接在一起作为最后一个参数。

```php
interface Pipeline
{
    public function dispatch(ServerRequestInterface $request): ResponseInterface;
}
```

And our implementation looks something like this:  
我们的实现看起来像这样：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Http;

use Psr\Container\ContainerInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

use function array_reverse;
use function assert;
use function is_string;

class ContainerPipeline implements Pipeline
{
    /**
     * @param array<MiddlewareInterface|class-string> $middlewares
     */
    public function __construct(
        private array $middlewares,
        private RequestHandlerInterface $tip,
        private ContainerInterface $container,
    ) {
    }

    public function dispatch(ServerRequestInterface $request): ResponseInterface
    {
        $this->buildStack();
        return $this->tip->handle($request);
    }

    private function buildStack(): void
    {
        foreach (array_reverse($this->middlewares) as $middleware) {
            $next = $this->tip;
            if ($middleware instanceof MiddlewareInterface) {
                $this->tip = $this->wrapMiddleware($middleware, $next);
            }
            if (is_string($middleware)) {
                $this->tip = $this->wrapResolvedMiddleware($middleware, $next);
            }
        }
    }

    private function wrapResolvedMiddleware(string $middleware, RequestHandlerInterface $next): RequestHandlerInterface
    {
        return new class ($middleware, $next, $this->container) implements RequestHandlerInterface {
            public function __construct(
                private readonly string $middleware,
                private readonly RequestHandlerInterface $handler,
                private readonly ContainerInterface $container,
            ) {
            }

            public function handle(ServerRequestInterface $request): ResponseInterface
            {
                $middleware = $this->container->get($this->middleware);
                assert($middleware instanceof MiddlewareInterface);
                return $middleware->process($request, $this->handler);
            }
        };
    }

    private function wrapMiddleware(MiddlewareInterface $middleware, RequestHandlerInterface $next): RequestHandlerInterface
    {
        return new class ($middleware, $next) implements RequestHandlerInterface {
            public function __construct(
                private readonly MiddlewareInterface $middleware,
                private readonly RequestHandlerInterface $handler,
            ) {
            }

            public function handle(ServerRequestInterface $request): ResponseInterface
            {
                return $this->middleware->process($request, $this->handler);
            }
        };
    }
}
```

Here we define our constructor to require two arguments: an array of middlewares and a requesthandler as the final code that should produce our response.  
在这里，我们将构造函数定义为需要两个参数：一个中间件数组和一个请求处理程序，作为最终的代码来生成我们的响应。

In the buildStack() method we wrap every middleware as a RequestHandler with the current tip property as the $next argument and store that itself as the current tip.  
在buildStack（）方法中，我们将每个中间件包装为RequestList，并将当前tip属性作为$next参数，并将其本身存储为当前tip。

There are of course a lot of more sophisticated ways to build a pipeline/dispatcher that you can check out at the [middlewares github](https://github.com/middlewares/awesome-psr15-middlewares#dispatcher)  
当然，还有很多更复杂的方法来构建管道/调度器，你可以在middlewares github上查看。

Lets add a simple factory to our dependencies.php file that creates our middlewarepipeline Lets create a simple Factory that loads an Array of Middlewares from the Config folder and uses that to build our pipeline  
让我们添加一个简单的工厂到我们的dependencies.php文件，创建我们的中间件管道让我们创建一个简单的工厂，从Config文件夹加载一个中间件数组，并使用它来构建我们的管道

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Factory;

use Lubian\NoFramework\Http\ContainerPipeline;
use Lubian\NoFramework\Http\Pipeline;
use Lubian\NoFramework\Http\RoutedRequestHandler;
use Lubian\NoFramework\Settings;
use Psr\Container\ContainerInterface;

class PipelineProvider
{
    public function __construct(
        private Settings $settings,
        private RoutedRequestHandler $tip,
        private ContainerInterface $container,
    ) {
    }

    public function getPipeline(): Pipeline
    {
        $middlewares = require $this->settings->middlewaresFile;
        return new ContainerPipeline($middlewares, $this->tip, $this->container);
    }
}
```

And configure the container to use the Factory to create the Pipeline:  
并配置容器以使用Factory创建Pipeline：

```php
    ...,
    Pipeline::class => fn (PipelineProvider $p) => $p->getPipeline(),
    ...
```

And of course a new file called middlewares.php in our config folder:  
当然，还有一个名为middlewares.php的新文件在我们的config文件夹中：

```php
<?php declare(strict_types=1);

use Lubian\NoFramework\Http\RouteMiddleware;
use Middlewares\TrailingSlash;
use Middlewares\Whoops;

return [
    Whoops::class,
    TrailingSlash::class,
    RouteMiddleware::class,
];
```

And we need to add the pipeline to our Kernel class. I will leave that as an exercise to you, a simple hint that i can give you is that the handle()-method of the Kernel should look like this:  
我们需要将管道添加到Kernel类中。我将把它作为练习留给你，我可以给予的一个简单提示是内核的handle（）方法应该是这样的：

```php
public function handle(ServerRequestInterface $request): ResponseInterface
{
    return $this->pipeline->dispatch($request);
}
```

Lets try if you can make the kernel work with our created Pipeline implementation. For the future we could improve our pipeline a little bit, so that it can accept a class-string of a middleware and resolves that with the help of a dependency container, if you want you can do that as well.  
让我们尝试一下，如果你能让内核与我们创建的管道实现一起工作。对于未来，我们可以稍微改进一下我们的管道，这样它就可以接受中间件的类字符串，并在依赖容器的帮助下解决这个问题，如果你愿意的话，你也可以这样做。

**A quick note about docblocks:** You might have noticed, that I rarely add docblocks to my the code in the examples, and when I do it seems kind of random. My philosophy is that I only add docblocks when there is no way to automatically get the exact type from the code itself. For me docblocks only serve two purposes: help my IDE to understand what it choices it has for code completion and to help the static analysis to better understand the code. There is a great blogpost about the [cost and value of DocBlocks](https://localheinz.com/blog/2018/05/06/cost-and-value-of-docblocks/), although it is written in 2018 at a time before PHP 7.4 was around everything written there is still valid today.  
关于docblocks的快速说明：你可能已经注意到了，我很少在示例中的代码中添加docblock，而且当我这样做时，它似乎是随机的。我的哲学是，我只在无法从代码本身自动获取确切类型的情况下添加docblock。对我来说，docblocks只有两个目的：帮助我的IDE理解它对代码完成的选择，以及帮助静态分析更好地理解代码。有一篇关于DocBlocks的成本和价值的博客文章，尽管它是在2018年写的，当时PHP 7.4还没有发布，但今天仍然有效。

### Adding Content 添加内容

By now we did not really display anything but some examples to in our application, and it is now time to make our app display some content. For example we could our app be able to display the Markdown files used in this tutorial as nicely rendered HTML Pages that can be viewed in the browser instead of the editor you are using.  
到目前为止，我们并没有真正显示任何东西，但在我们的应用程序中的一些例子，现在是时候让我们的应用程序显示一些内容。例如，我们的应用程序可以将本教程中使用的Markdown文件显示为可以在浏览器中查看的HTML页面，而不是您正在使用的编辑器。

So lets start by copying the markdown files to our app directory. I have created a new folder 'data/pages' and placed all the markdown files in there.  
因此，让我们从将markdown文件复制到我们的应用程序目录开始。我已经创建了一个新的文件夹“data/pages”，并将所有的markdown文件放在那里。

Next we need a markdown parser, a pretty simple one is [Parsedown](https://parsedown.org/), if you want more features you could also use the [Commonmark parser](https://commonmark.thephpleague.com/). I will choose Parsedown here, but you can use whatever you like.  
接下来我们需要一个markdown解析器，一个非常简单的是Parsedown，如果你想要更多的功能，你也可以使用Commonmark解析器。我会在这里选择Parsedown，但你可以使用任何你喜欢的。

After installing Parsedown lets write a Markdownparser interface and an implementation using parsedown.  
安装Parsedown后，让我们编写一个Markdownparser接口和一个使用parsedown的实现。

We only need one function that receives a string of Markdown and returns the HTML representation (as a string as well).  
我们只需要一个函数来接收Markdown的字符串并返回HTML表示（也作为字符串）。

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Template;

interface MarkdownParser
{
    public function parse(string $markdown): string;
}
```

By the namespace you will already have guessed that I placed in interface in a file calles MarkdownParser.php in the src/Template folder. Let's put our Parsedown implementation right next to it in a file called ParsedownParser.php  
通过命名空间，你可能已经猜到我在接口中放置了一个名为MarkdownParser.php的文件，该文件位于src/Template文件夹中。让我们将Parsedown实现放在一个名为ParsedownParser.php的文件中，

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Template;

use Parsedown;

final class ParsedownRenderer implements MarkdownParser
{
    public function __construct(private Parsedown $parser)
    {
    }

    public function parse(string $markdown): string
    {
        return $this->parser->parse($markdown);
    }
}
```

We could now use the ParsedownRender class directly in our actions by typehinting the classname as an argument to the constructor or a method, but as we always want to rely on an interface instead of an implementation we need to define the ParsedownRenderer as the correct implementation for the MarkdownRenderer interface in the dependencies file:  
我们现在可以直接在动作中使用ParsedownRenderer类，方法是将类名作为构造函数或方法的参数，但是由于我们总是希望依赖于接口而不是实现，因此我们需要在依赖文件中将ParsedownRenderer定义为MarkdownRenderer接口的正确实现：

```php
...
    \Lubian\NoFramework\Template\MarkdownParser::class => fn(\Lubian\NoFramework\Template\ParsedownParser $p) => $p,
...
```

You can test that in our "Other.php" action and try out if the Parser works and is able to render Markdown to HTML:  
你可以在我们的"php.php"操作中测试一下，看看解析器是否工作，是否能够将Markdown渲染为HTML：

```php
public function someFunctionName(ResponseInterface $response, MarkdownParser $parser): ResponseInterface
{
    $html = $parser->parse('This *works* **too!**');
    $response->getBody()->write($html);
    return $response->withStatus(200);
}
```

But we want to display complete Pages written in Markdown, it would also be neat to be able to display a list of all available pages. For that we need a few things:  
但是我们希望显示用Markdown编写的完整页面，能够显示所有可用页面的列表也会很整洁。为此，我们需要一些东西：

Firstly we need two new Templates, one for the list of the Pages, and the second one for displaying a single pages content. Create a new folder in `templates/page` with to files:  
首先，我们需要两个新的模板，一个用于页面列表，第二个用于显示单个页面内容。在 `templates/page` 中创建一个新文件夹，包含to文件：

`templates/page/list.html`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pages</title>
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.classless.min.css">
</head>
<body>
<main>
    <ul>
        {{#pages}}
        <li>
            <a href="/page/{{title}}">{{id}}: {{title}}</a>
        </li>
        {{/pages}}
    </ul>
</main>
</body>
</html>
```

This template iterates over a provided array of pages, each element consists of the two properties: an id and a title, those are simply displayed using an unordered list.  
这个模板遍历一个提供的页面数组，每个元素由两个属性组成：一个id和一个title，它们只是使用一个无序列表显示。

`templates/page/show.html`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{title}}</title>
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.classless.min.css">
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script> 
</head>
<body>
<main>
    {{{content}}}
</main>
</body>
</html>
```

The second templates displays a single rendered markdown page. As data it expects the title and the content as array. I used an extra bracket for the content `{{{content}}}` so that the Mustache-Renderer does not escape the provided html and thereby destroys the parsed markdown.  
第二个模板显示单个呈现的markdown页面。作为数据，它期望标题和内容作为数组。我为内容 `{{{content}}}` 使用了一个额外的括号，这样Mustache-Renderer就不会转义提供的html，从而破坏解析后的markdown。

You might have spotted that I added [Pico.css](https://picocss.com/) which is just a very small css framework to make the pages a little nicer to look at. It mostly provides some typography styles that work great with rendered Markdown, but you can leave that out or use any other css framework you like. There is also some Javascript that adds syntax highlighting to the code.  
你可能已经注意到我添加了Pico.css，这只是一个非常小的css框架，使页面看起来更好看。它主要提供了一些排版风格，可以很好地与渲染的Markdown一起工作，但你可以忽略它或使用任何其他你喜欢的CSS框架。也有一些JavaScript在代码中添加语法高亮。

After you have taken care of the templating side we can now create an new Action class with two methods to display use our markdown files and the templates to create the pages. As we have two templates I propose to use Two methods in our Action: `src/Action/Page.php`  
在你处理好模板方面之后，我们现在可以创建一个新的Action类，它有两个方法来显示，使用我们的markdown文件和模板来创建页面。由于我们有两个模板，我建议在Action中使用两种方法： `src/Action/Page.php`

```php
function show(string $name): \Psr\Http\Message\ResponseInterface;
function list(): \Psr\Http\Message\ResponseInterface;
```

Let's define two routes. `/page` should display the overview of all pages, and if the add the name of chapter to the route, `/page/adding-content` for example, the show action should be called with the name as a variable:  
让我们定义两条路线。 `/page` 应该显示所有页面的概述，如果将章节名称添加到路由中，例如 `/page/adding-content` ，则应使用名称作为变量调用show操作：

`config/routes.php`

```php
$r->addRoute('GET', '/page', [Page::class, 'list']);
$r->addRoute('GET', '/page/{page}', [Page::class, 'show']);
```

Here is my Implementation. I have added a little regex replacement in the show method that replaces the links to the next and previous chapter so that it works with our routing configuration.  
这是我的实现。我在show方法中添加了一个小的regex替换，它替换了下一章和上一章的链接，以便它与我们的路由配置一起工作。

`src/Action/Page.php`

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Action;

use Lubian\NoFramework\Exception\InternalServerError;
use Lubian\NoFramework\Template\MarkdownParser;
use Lubian\NoFramework\Template\Renderer;
use Psr\Http\Message\ResponseInterface;

use function array_filter;
use function array_map;
use function array_values;
use function file_get_contents;
use function glob;
use function preg_replace;
use function str_contains;
use function str_replace;
use function substr;

class Page
{
    public function __construct(
        private ResponseInterface $response,
        private MarkdownParser $parser,
        private Renderer $renderer,
        private string $pagesPath = __DIR__ . '/../../data/pages/'
    ) {
    }

    public function show(
        string $page,
    ): ResponseInterface {
        $page = array_values(
            array_filter(
                $this->getPages(),
                fn (string $filename) => str_contains($filename, $page)
            )
        )[0];
        $markdown = file_get_contents($page);

        // fix the next and previous buttons to work with our routing
        $markdown = preg_replace('/\(\d\d-/m', '(', $markdown);
        $markdown = str_replace('.md)', ')', $markdown);

        $page = str_replace([$this->pagesPath, '.md'], ['', ''], $page);
        $data = [
            'title' => substr($page, 3),
            'content' => $this->parser->parse($markdown),
        ];
        $html = $this->renderer->render('page/show', $data);
        $this->response->getBody()->write($html);
        return $this->response;
    }

    public function list(): ResponseInterface
    {
        $pages = array_map(function (string $page) {
            $page = str_replace([$this->pagesPath, '.md'], ['', ''], $page);
            return [
                'id' => substr($page, 0, 2),
                'title' => substr($page, 3),
            ];
        }, $this->getPages());
        $html = $this->renderer->render('page/list', ['pages' => $pages]);
        $this->response->getBody()->write($html);
        return $this->response;
    }

    /**
     * @return string[]
     */
    private function getPages(): array
    {
        $files = glob($this->pagesPath . '*.md');
        if ($files === false) {
            throw new InternalServerError('cannot read pages');
        }
        return $files;
    }
}
```

You can now navigate your Browser to [localhost:1235/page][http://localhost:1235/page] and try out if everything works.  
您现在可以将浏览器导航到[localhost：1235/page][http：//localhost：1235/page]并尝试是否一切正常。

Of course this code is far from looking good. We heavily rely on the pages being files in the filesystem, and the action should never be aware of the filesystem in the first place, also we have a lot of string replacements and other repetitive code in the file. And phpstan is going to scream at us a lot, but if we rewrite the code to satisfy all the checks we would add even more lines to that simple class, so lets move on to the next chapter where we move all the logic to separate classes following our holy SOLID principles :)  
当然，这段代码看起来并不好。我们严重依赖于页面是文件系统中的文件，并且操作首先不应该知道文件系统，而且我们在文件中有很多字符串替换和其他重复代码。phpstan会对我们大喊大叫，但是如果我们重写代码来满足所有的检查，我们会在这个简单的类中添加更多的行，所以让我们进入下一章，在那里我们将所有的逻辑移动到单独的类中，遵循我们神圣的SOLID原则：）

## Data Repository 数据储存库

At the end of the last chapter I mentioned being unhappy with our Pages action, because there is too much stuff happening there. We are firstly receiving some Arguments, then we are using those to query the filesystem for the given page, loading the specific file from the filesystem, rendering the markdown, passing the markdown to the template renderer, adding the resulting html to the response and then returning the response.  
在上一章的结尾，我提到了对我们的Pages行动的不满，因为那里发生了太多的事情。我们首先接收一些参数，然后使用这些参数来查询给定页面的文件系统，从文件系统加载特定文件，渲染markdown，将markdown传递给模板渲染器，将生成的html添加到响应中，然后返回响应。

In order to make our page-action independent of the filesystem and move the code that is responsible for reading the files to a better place I want to introduce the [Repository Pattern](https://designpatternsphp.readthedocs.io/en/latest/More/Repository/README.html).  
为了使我们的页面操作独立于文件系统，并将负责阅读文件的代码移动到一个更好的地方，我想引入存储库模式。

I want to start by creating a class that represents the Data that is included in a page so that. For now, I can spot three distinct attributes.  
我想先创建一个类，它表示包含在页面中的数据，以便。目前，我可以看出三个明显的特征。

- the ID (or chapter-number)  
  ID（或章节号）
- the title (or name)  
  标题（或名称）
- the content 内容

Currently, all those properties are always available, but we might later be able to create new pages and store them, but at that point in time we are not yet aware of the new available ID, so we should leave that property nullable. This allows us to create an object without an id and let the code that actually saves the object to a persistent store define a valid id on saving.  
目前，所有这些属性都是始终可用的，但我们稍后可能能够创建新页面并存储它们，但此时我们还不知道新的可用ID，因此我们应该将该属性保留为空。这允许我们创建一个没有id的对象，并让实际将对象保存到持久存储的代码在保存时定义一个有效的id。

Let's create an new Namespace called `Model` and put a `MarkdownPage.php` class in there:  
让我们创建一个新的命名空间 `Model` ，并在其中放置一个 `MarkdownPage.php` 类：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Model;

class MarkdownPage
{
    public function __construct(
        public string $title,
        public string $content,
        public int|null $id = null,
    ) {
    }
}
```

These small Model classes are one of my most favorite features in newer PHP-Versions, because they are almost as easy to create as an on-the-fly array but give us the great benefit of type safety as well as full code completion in our IDEs. There is a [great blogpost](https://stitcher.io/blog/evolution-of-a-php-object) that highlights how this kind of objects have evolved in PHP from version 5.6 to 8.1, as I personally first started writing proper php with 5.4 it really baffles me how far the language has evolved in these last years.  
这些小的Model类是我最喜欢的PHP新版本的特性之一，因为它们几乎和动态数组一样容易创建，但给予我们IDE中类型安全和完整代码完成的巨大好处。有一个很棒的博客文章强调了这种对象在PHP中从5.6版本到8.1版本的演变，因为我个人第一次开始用5.4编写正确的PHP，它真的让我困惑，在过去的几年里，这种语言已经发展了多远。

Next we can define our interface for the repository, for our current use case I see only two needed methods:  
接下来，我们可以为仓库定义接口，对于我们当前的用例，我只看到两个需要的方法：

- get all pages 获取所有页面
- get one page by name  
  按名称获取一页

The `all()` method should return an array of all available pages (or an empty one if there are none), and the `byName(string $name)` method should either return exactly one page or throw a NotFound-Exception. You decide to return `false` or `null` if no page with the given name could be found, but I personally prefer exception, as that keeps the return type checking simpler and we can decide at what layer of the application we want to handle a miss on that function.  
`all()` 方法应该返回一个所有可用页面的数组（如果没有，则返回一个空数组），而 `byName(string $name)` 方法应该返回一个页面或抛出NotFound-Exception。如果找不到给定名称的页面，您可以决定返回 `false` 或 `null` ，但我个人更喜欢异常，因为这可以使返回类型检查更简单，并且我们可以决定在应用程序的哪个层处理该函数的未命中。

With that said we can now define create a `Repository` namespace and place a `MarkdownPageRepo.php` there:  
现在我们可以定义创建一个 `Repository` 命名空间，并在那里放置一个 `MarkdownPageRepo.php` ：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Repository;

use Lubian\NoFramework\Exception\NotFound;
use Lubian\NoFramework\Model\MarkdownPage;

interface MarkdownPageRepo
{
    /** @return MarkdownPage[] */
    public function all(): array;
    /** @throws NotFound */
    public function byName(string $name): MarkdownPage;
}
```

Now we can write an implementation for this interface and move our code from to Action there: `src/Repository/FilesystemMarkdownPageRepo.php`  
现在我们可以为这个接口编写一个实现，并将我们的代码从这里移动到Action： `src/Repository/FilesystemMarkdownPageRepo.php`

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Repository;

use Lubian\NoFramework\Exception\InternalServerError;
use Lubian\NoFramework\Exception\NotFound;
use Lubian\NoFramework\Model\MarkdownPage;

use function array_filter;
use function array_map;
use function array_values;
use function count;
use function file_get_contents;
use function glob;
use function str_replace;
use function substr;

final class FileSystemMarkdownPageRepo implements MarkdownPageRepo
{
    public function __construct(
        private readonly string $dataPath
    ) {
    }

    /** @inheritDoc  */
    public function all(): array
    {
        $files = glob($this->dataPath . '*.md');
        if ($files === false) {
            throw new InternalServerError('cannot read pages');
        }
        return array_map(function (string $filename) {
            $content = file_get_contents($filename);
            if ($content === false) {
                throw new InternalServerError('cannot read pages');
            }
            $idAndTitle = str_replace([$this->dataPath, '.md'], ['', ''], $filename);
            return new MarkdownPage(
                (int) substr($idAndTitle, 0, 2),
                substr($idAndTitle, 3),
                $content
            );
        }, $files);
    }

    public function byName(string $name): MarkdownPage
    {
        $pages = array_values(
            array_filter(
                $this->all(),
                fn (MarkdownPage $p) => $p->title === $name,
            )
        );

        if (count($pages) !== 1) {
            throw new NotFound;
        }

        return $pages[0];
    }
}
```

With that in place we need to add the required `$pagesPath` to our settings class and add specify that in our configuration.  
有了这些，我们需要将所需的 `$pagesPath` 添加到我们的设置类中，并在我们的配置中添加指定。

`src/Settings.php`

```php
final class Settings
{
    public function __construct(
        public readonly string $environment,
        public readonly string $dependenciesFile,
        public readonly string $middlewaresFile,
        public readonly string $templateDir,
        public readonly string $templateExtension,
        public readonly string $pagesPath,
    ) {
    }
}
```

`config/settings.php`

```php
return new Settings(
    environment: 'prod',
    dependenciesFile: __DIR__ . '/dependencies.php',
    middlewaresFile: __DIR__ . '/middlewares.php',
    templateDir: __DIR__ . '/../templates',
    templateExtension: '.html',
    pagesPath: __DIR__ . '/../data/pages/',
);
```

Of course, we need to define the correct implementation for the container to choose when we are requesting the Repository interface: `conf/dependencies.php`  
当然，我们需要定义正确的实现，以便容器在请求Repository接口时选择： `conf/dependencies.php`

```php
MarkdownPageRepo::class => fn (FileSystemMarkdownPageRepo $r) => $r,
FileSystemMarkdownPageRepo::class => fn (Settings $s) => new FileSystemMarkdownPageRepo($s->pagesPath),
```

Now you can request the MarkdownPageRepo Interface in your page action and use the defined functions to get the MarkdownPage Objects. My `src/Action/Page.php` looks like this now:  
现在，您可以在页面操作中请求MarkdownPageRepo接口，并使用定义的函数来获取MarkdownPage对象。我的 `src/Action/Page.php` 现在看起来像这样：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Action;

use Lubian\NoFramework\Model\MarkdownPage;
use Lubian\NoFramework\Repository\MarkdownPageRepo;
use Lubian\NoFramework\Template\MarkdownParser;
use Lubian\NoFramework\Template\Renderer;
use Psr\Http\Message\ResponseInterface;

use function array_map;
use function assert;
use function is_string;
use function preg_replace;
use function str_replace;

class Page
{
    public function __construct(
        private ResponseInterface $response,
        private MarkdownParser $parser,
        private Renderer $renderer,
        private MarkdownPageRepo $repo,
    ) {
    }

    public function show(
        string $page,
    ): ResponseInterface {
        $page = $this->repo->byName($page);

        // fix the next and previous buttons to work with our routing
        $content = preg_replace('/\(\d\d-/m', '(', $page->content);
        assert(is_string($content));
        $content = str_replace('.md)', ')', $content);

        $data = [
            'title' => $page->title,
            'content' => $this->parser->parse($content),
        ];

        $html = $this->renderer->render('page/show', $data);
        $this->response->getBody()->write($html);
        return $this->response;
    }

    public function list(): ResponseInterface
    {
        $pages = array_map(function (MarkdownPage $page) {
            return [
                'id' => $page->id,
                'title' => $page->content,
            ];
        }, $this->repo->all());

        $html = $this->renderer->render('page/list', ['pages' => $pages]);
        $this->response->getBody()->write($html);
        return $this->response;
    }
}
```

Check the page in your browser if everything still works, don't forget to run phpstan and the others fixers before committing your changes and moving on to the next chapter.  
在浏览器中检查页面，如果一切正常，在提交更改并进入下一章之前，不要忘记运行phpstan和其他修复程序。

## Autoloading performance 自动加载性能

Although our application is still very small, and you should not really experience any performance issues right now, there are still some things we can already consider and take a look at. If I check the network tab in my browser it takes about 90-400ms to show a simple rendered markdown, with is sort of ok but in my opinion way to long as we are not really doing anything and do not connect to any external services. Mostly we are just reading around 16 markdown files, a template, some config files here and there and parse some markdown. So that should not really take that long.  
虽然我们的应用程序仍然非常小，而且您现在应该不会遇到任何性能问题，但仍然有一些事情我们可以考虑并查看一下。如果我在浏览器中检查网络选项卡，它需要大约90- 400毫秒才能显示一个简单的渲染标记，这还可以，但在我看来，只要我们没有真正做任何事情，也没有连接到任何外部服务。大多数情况下，我们只是阅读大约16个markdown文件，一个模板，一些配置文件在这里和那里，并解析一些markdown。所以应该不会花那么长时间。

The problem is, that we heavily rely on autoload for all our class files, in the `src` folder. And there are also quite a lot of other files in composers `vendor` directory. To understand while this is becoming we should make ourselves familiar with how [autoloading in php](https://www.php.net/manual/en/language.oop5.autoload.php) works.  
问题是，我们严重依赖于自动加载所有的类文件，在 `src` 文件夹中。在composers `vendor` 目录中还有很多其他文件。为了理解这一点，我们应该熟悉php中自动加载的工作原理。

The basic idea is, that every class that php encounters has to be loaded from somewhere in the filesystem, we could just require the files manually but that is tedious, unflexible and can often cause errors.  
基本的想法是，php遇到的每个类都必须从文件系统的某个地方加载，我们可以手动地要求文件，但这是乏味的，不灵活的，而且经常会导致错误。

The problem we are now facing is that the composer autoloader has some rules to determine from where in the filesystem a class definition might be placed, then the autoloader tries to locate a file by the namespace and classname and if it exists includes that file.  
我们现在面临的问题是，composer autoloader有一些规则来确定类定义可能被放置在文件系统中的位置，然后autoloader试图通过命名空间和classname来定位文件，如果它存在，则包括该文件。

If we only have a handful of classes that does not take a lot of time, but as we are growing with our application this easily takes longer than necessary, but fortunately composer has some options to speed up the class loading.  
如果我们只有少量的类，这不会花费很多时间，但随着我们的应用程序不断增长，这很容易花费比必要的时间更长的时间，但幸运的是，composer有一些选项来加速类加载。

Take a few minutes to read the documentation about [composer autoloader optimization](https://getcomposer.org/doc/articles/autoloader-optimization.md)  
花几分钟时间阅读有关composer autoloader优化的文档

You can try all 3 levels of optimizations, but we are going to stick with the first one for now, so lets create an optimized classmap.  
您可以尝试所有3个级别的优化，但我们现在将坚持使用第一个级别，因此让我们创建一个优化的类映射。

`composer dump-autoload -o`

After composer has finished you can start the devserver again with `composer serve` and take a look at the network tab in your browsers devtools.  
composer完成后，您可以使用 `composer serve` 再次启动devserver，并查看浏览器devtools中的网络选项卡。

In my case the response time falls down to under an average of 30ms with some spikes in between, but all in all it looks really good. You can also try out the different optimization levels and see if you can spot any differences.  
在我的情况下，响应时间福尔斯下降到平均30毫秒以下，其间有一些尖峰，但总而言之，它看起来真的很好。您还可以尝试不同的优化级别，看看是否可以发现任何差异。

Although the composer manual states not to use the optimization in a dev environment I personally have not encountered any errors with the first level of optimizations, so we can use that level here. If you add the line from the documentation to your `composer.json` so that the autoloader gets optimized everytime we install new packages.  
虽然composer手册声明不要在开发环境中使用优化，但我个人在第一级优化中没有遇到任何错误，所以我们可以在这里使用该级别。如果您将文档中的这一行添加到您的 `composer.json` 中，那么每次安装新软件包时，自动加载器都会得到优化。

**DISClAIMER** I do not really have a lot of experience when it comes to caching, so this chapter is mostly some random thoughts and ideas I wanted to explore when writing this tutorial, you should definitely take everything that is being said here with caution and try to read up on some other sources. But that holds true for the whole tutorial anyway :)  
disclaimer我真的没有太多的经验，当谈到缓存，所以这一章主要是一些随机的想法和想法，我想探讨当写这篇教程，你一定要采取一切都是在这里所说的谨慎，并尝试阅读一些其他来源。但无论如何，这对整个教程都是正确的：）

## [](https://git.php.fail/lubiana/no-framework-tutorial/src/branch/master/18-caching.md#caching)Caching 缓存

In the last chapter we greatly improved the perfomance for the lookup of all our classfiles, but currently we do not have any real bottlenecks in our application like complex queries.  
在上一章中，我们大大提高了查找所有类文件的性能，但目前我们在应用程序中没有任何真实的瓶颈，比如复杂的查询。

But in a real application we are going to execute some really heavy and time intensive database queries that can take quite a while to be completed.  
但在一个真实的应用程序中，我们将执行一些非常繁重和耗时的数据库查询，这些查询可能需要相当长的时间才能完成。

We can simulate that by adding a simple delay in our `FileSystemMarkdownPageRepo`.  
我们可以通过在 `FileSystemMarkdownPageRepo` 中添加一个简单的延迟来模拟它。

```php
 return array_map(function (string $filename) {
        usleep(rand(100, 400) * 1000);
        $content = file_get_contents($filename);
        if ($content === false) {
            throw new InternalServerError('cannot read pages');
        }
        $idAndTitle = str_replace([$this->dataPath, '.md'], ['', ''], $filename);
        return new MarkdownPage(
            (int) substr($idAndTitle, 0, 2),
            substr($idAndTitle, 3),
            $content
        );
});
```

Here I added a function that pauses the scripts execution for a random time between 100 and 400ms for every markdownpage in every call of the `all()` method.  
这里我添加了一个函数，它在每次调用 `all()` 方法时，为每个markdownpage暂停脚本执行100到400毫秒之间的随机时间。

If you open any page or even the listAction in you browser you will see, that it takes quite a time to render that page. Although this is a silly example we do not really need to query the database on every request, so lets add a way to cache the database results between requests.  
如果你在浏览器中打开任何一个页面，甚至是listAction，你会看到，渲染这个页面需要相当长的时间。虽然这是一个愚蠢的例子，但我们并不需要在每个请求中都查询数据库，所以让我们添加一种方法来缓存请求之间的数据库结果。

The PHP-Community has already adressed the issue of having easy to use access to cache libraries, there is the [PSR-6 Caching Interface](https://www.php-fig.org/psr/psr-6) which gives us easy access to many different implementations, then there is also a much simpler [PSR-16 Simple Cache](https://www.php-fig.org/psr/psr-16) which makes the use even more easy, and most Caching Libraries implement Both interfaces anyway. You would think that this is more than enough solutions to satisfy all the Caching needs around, but the Symfony People decided that Caching should be even simpler and easier to use and defined their own [Interface](https://symfony.com/doc/current/components/cache.html#cache-component-contracts) which only needs two methods. You should definitely take a look at the linked documentation as it really blew my mind when I first encountered it.  
PHP社区已经解决了容易使用缓存库的问题，有PSR-6缓存接口，它让我们可以轻松访问许多不同的实现，还有一个更简单的PSR-16简单缓存，它使使用更加容易，大多数缓存库都实现了这两个接口。你可能会认为这已经足够满足所有的缓存需求了，但是Symfony的人认为缓存应该更简单，更容易使用，并且定义了他们自己的接口，只需要两个方法。你绝对应该看看链接的文档，因为当我第一次遇到它时，它真的让我大吃一惊。

The basic idea is that you provide a callback that computes the requested value. The Cache implementation then checks if it already has the value stored somewhere and if it doesnt it just executes the callback and stores the value for future calls.  
其基本思想是提供一个回调函数来计算请求的值。然后，该高速缓存实现检查是否已经将该值存储在某个位置，如果没有，则执行回调并存储该值以供将来调用。

It is really simple and great to use. In a real world application you should definitely use that or a PSR-16 implementation but for this tutorial I wanted to roll out my own solution, so here we go.  
这是非常简单和伟大的使用。在一个真实的应用程序中，你绝对应该使用它或PSR-16实现，但对于本教程，我想推出我自己的解决方案，所以我们开始吧。

As always we are going to define an interface first, I am going to call it EasyCache and place it in the `Service/Cache` namespace. I will require only one method which is base on the Symfony Cache Contract, and hast a key, a callback, and the duration that the item should be cached as arguments.  
和往常一样，我们首先要定义一个接口，我将把它命名为EasyCache，并把它放在 `Service/Cache` 命名空间中。我只需要一个基于Symfony Cache Contract的方法，并有一个键，一个回调函数，以及该项目应该作为参数缓存的持续时间。

```php
<?php

declare(strict_types=1);

namespace Lubian\NoFramework\Service\Cache;

interface EasyCache
{
    /** @param callable(): mixed $callback */
    public function get(string $key, callable $callback, int $ttl = 0): mixed;
}
```

For the implementation I am going to use the [APCu Extension](https://www.php.net/manual/en/ref.apcu.php) for PHP, but if you are particularly adventurous you can write an implementation using memcache, the filesystem, a database, redis or whatever you desire.  
对于实现，我将使用APCu Extension for PHP，但如果你特别喜欢冒险，你可以使用memcache、文件系统、数据库、redis或任何你想要的东西来编写一个实现。

For the sake of writing as less code as possible here is my simple `ApcuCache.php`  
为了写尽可能少的代码，这里是我的简单 `ApcuCache.php`

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Service\Cache;

use function apcu_add;
use function apcu_fetch;

final class ApcuCache implements EasyCache
{
    public function get(string $key, callable $callback, int $ttl = 0): mixed
    {
        $success = false;
        $result = apcu_fetch($key, $success);
        if ($success === true) {
            return $result;
        }
        $result = $callback();
        apcu_add($key, $result, $ttl);
        return $result;
    }
}
```

Now that we have a usable implementation for our cache we can write an implementation of our `MarkdownPageRepo` interface that usese the Cache and a Repository implementation to speed up the time exepensive calls.  
现在我们已经有了一个可用的缓存实现，我们可以编写一个 `MarkdownPageRepo` 接口的实现，它使用该高速缓存和一个Repository实现来加速时间消耗调用。

So lets create a new class called `CachedMarkdownPageRepo`:  
因此，我们创建一个名为 `CachedMarkdownPageRepo` 的新类：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Repository;

use Lubian\NoFramework\Model\MarkdownPage;
use Lubian\NoFramework\Service\Cache\EasyCache;

use function base64_encode;

final class CachedMarkdownPageRepo implements MarkdownPageRepo
{
    public function __construct(
        private EasyCache $cache,
        private MarkdownPageRepo $repo,
    ) {
    }

    /**
     * @inheritDoc
     */
    public function all(): array
    {
        $key = base64_encode(self::class . 'all');
        return $this->cache->get(
            $key,
            fn () => $this->repo->all(),
            300
        );
    }

    public function byName(string $name): MarkdownPage
    {
        $key = base64_encode(self::class . 'byName' . $name);
        return $this->cache->get(
            $key,
            fn () => $this->repo->byName($name),
            300
        );
    }
}
```

This simple wrapper just requires an EasyCache implementation and a MarkdownPageRepo in the constructor and uses them to cache all queries for 5 minutes. The beauty is that we are not dependent on any implementation here, so we can switch out the Repository or the Cache at any point down the road if we want to.  
这个简单的包装器只需要一个EasyCache实现和构造函数中的MarkdownPageRepo，并使用它们缓存所有查询5分钟。美妙之处在于，我们不依赖于任何实现，因此如果需要，我们可以随时切换Repository或该高速缓存。

In order to use that we need to update our `config/dependencies.php` to add an alias for the EasyCache interface as well as defining our CachedMarkdownPageRepo as implementation for the MarkdownPageRepo interface:  
为了使用它，我们需要更新我们的 `config/dependencies.php` 来为EasyCache接口添加一个别名，并将我们的CachedMarkdownPageRepo定义为MarkdownPageRepo接口的实现：

```php
MarkdownPageRepo::class => fn (CachedMarkdownPageRepo $r) => $r,
EasyCache::class => fn (ApcuCache $c) => $c,
```

If we try to access our webpage now, we are getting an error, as PHP-DI has detected a circular dependency that cannot be autowired.  
如果我们现在尝试访问我们的网页，我们会得到一个错误，因为PHP-DI检测到一个不能自动连接的循环依赖。

The Problem is that our CachedMarkdownPageRepo ist defined as the implementation for the MarkdownPageRepo, but it also requires that exact interface as a dependency. To resolve this issue we need to manually tell the container how to build the CachedMarkdownPageRepo by adding another line to the `config/dependencies.php` file:  
问题是我们的CachedMarkdownPageRepo被定义为MarkdownPageRepo的实现，但它也需要确切的接口作为依赖。要解决这个问题，我们需要手动告诉容器如何构建CachedMarkdownPageRepo，方法是在 `config/dependencies.php` 文件中添加另一行：

```php
CachedMarkdownPageRepo::class => fn (EasyCache $c, FileSystemMarkdownPageRepo $r) => new CachedMarkdownPageRepo($c, $r),
```

Here we explicitly require the FileSystemMarkdownPageRepo and us that to create the CachedMarkdownPageRepo object.  
这里我们显式地要求FileSystemMarkdownPageRepo和us来创建CachedMarkdownPageRepo对象。

When you now navigate to the pages list or to a specific page the first load should take a while (because of our added delay) but the following request should be answered blazingly fast.  
当你现在导航到页面列表或一个特定的页面时，第一次加载应该需要一段时间（因为我们增加了延迟），但是下面的请求应该会很快得到响应。

Before moving on to the next chapter we can take the caching approach even further, in the middleware chapter I talked about a simple CachingMiddleware that caches all the GET-Request for some seconds, as they should not change that often, and we can bypass most of our application logic if we just complelety cache away the responses our application generates, and return them quite early in our Middleware-Pipeline befor the router gets called, or the invoker calls the action, which itself uses some other services to fetch all the needed data.  
在进入下一章之前，我们可以更深入地了解缓存方法，在中间件一章中，我谈到了一个简单的CachingMiddleware，它可以将所有的GET请求缓存几秒钟，因为它们不应该经常改变，如果我们完全缓存我们的应用程序生成的响应，我们可以绕过我们的大部分应用程序逻辑，并在我们的中间件管道中很早就返回它们，因为路由器被调用，或者调用者调用动作，动作本身使用一些其他服务来获取所有需要的数据。

We will introduce a new `Middleware` namespace to place our `Cache.php` middleware:  
我们将引入一个新的 `Middleware` 命名空间来放置我们的 `Cache.php` 中间件：

```php
<?php declare(strict_types=1);

namespace Lubian\NoFramework\Middleware;

use Laminas\Diactoros\Response\Serializer;
use Lubian\NoFramework\Service\Cache\EasyCache;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

use function base64_encode;

final class Cache implements MiddlewareInterface
{
    public function __construct(
        private readonly EasyCache $cache,
        private readonly Serializer $serializer,
    ) {
    }

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        if ($request->getMethod() !== 'GET') {
            return $handler->handle($request);
        }
        $keyHash = base64_encode($request->getUri()->getPath());
        $result = $this->cache->get(
            $keyHash,
            fn () => $this->serializer::toString($handler->handle($request)),
            300
        );
        return $this->serializer::fromString($result);
    }
}
```

The code is quite straight forward, but you might be confused by the Responseserializer I have added here, we need this because the response body is a stream object, which doesnt always gets serialized correctly, therefore I use a class from the laminas project to to all the heavy lifting for us.  
代码很简单，但是你可能会被我在这里添加的Responseserializer弄糊涂，我们需要这个，因为响应体是一个流对象，它并不总是正确地被序列化，因此我使用了laminas项目中的一个类来为我们解决所有的难题。

We need to add the now middleware to the `config/middlewares.php` file.  
我们需要将now中间件添加到 `config/middlewares.php` 文件中。

```php
<?php declare(strict_types=1);

use Lubian\NoFramework\Http\RouteMiddleware;
use Lubian\NoFramework\Middleware\Cache;
use Middlewares\TrailingSlash;
use Middlewares\Whoops;

return [
    Whoops::class,
    Cache::class,
    TrailingSlash::class,
    RouteMiddleware::class,
];
```

You can now use your browser to look if everything works as expected.  
您现在可以使用浏览器查看是否一切都按预期工作。

**Disclaimer** in a real application you would take some more consideration when it comes to caching and this simple response cache would quickly get in you way, but as I said earlier this chapter was mostly me playing around with some ideas I had in writing this tutorial.  
免责声明在一个真实的应用程序中，当涉及到缓存时，你会更多地考虑这个简单的响应缓存，但是正如我前面所说的，这一章主要是我在写这篇教程时的一些想法。
